/*
THIS IS A GENERATED/BUNDLED FILE BY VITE
if you want to view the source, please visit the github repository https://github.com/Myriad-Dreamin/typst.ts/blob/main/packages/typst.ts
*/
var sr = Object.defineProperty;
var or = (n, e, t) => e in n ? sr(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var l = (n, e, t) => or(n, typeof e != "symbol" ? e + "" : e, t);
const ar = [
  "LinLibertine_R.ttf",
  "LinLibertine_RB.ttf",
  "LinLibertine_RBI.ttf",
  "LinLibertine_RI.ttf",
  "NewCMMath-Book.otf",
  "NewCMMath-Regular.otf",
  "NewCM10-Regular.otf",
  "NewCM10-Bold.otf",
  "NewCM10-Italic.otf",
  "NewCM10-BoldItalic.otf",
  "DejaVuSansMono.ttf",
  "DejaVuSansMono-Bold.ttf",
  "DejaVuSansMono-Oblique.ttf",
  "DejaVuSansMono-BoldOblique.ttf"
], cr = [
  "InriaSerif-Bold.ttf",
  "InriaSerif-BoldItalic.ttf",
  "InriaSerif-Italic.ttf",
  "InriaSerif-Regular.ttf",
  "Roboto-Regular.ttf",
  "NotoSerifCJKsc-Regular.otf"
], _r = ["TwitterColorEmoji.ttf", "NotoColorEmoji.ttf"];
function $e(n, e) {
  var i, s;
  const t = [...n];
  if (e && (e == null ? void 0 : e.assets) !== !1 && ((i = e == null ? void 0 : e.assets) != null && i.length) && ((s = e == null ? void 0 : e.assets) == null ? void 0 : s.length) > 0) {
    let o = e.assetUrlPrefix ?? "https://raw.githubusercontent.com/Myriad-Dreamin/typst/assets-fonts";
    o[o.length - 1] !== "/" && (o += "/");
    const a = (u) => u.map((d) => o + d);
    for (const u of e.assets)
      switch (u) {
        case "text":
          t.push(...a(ar));
          break;
        case "cjk":
          t.push(...a(cr));
          break;
        case "emoji":
          t.push(...a(_r));
          break;
      }
  }
  const r = async (o, { ref: a, builder: u }) => {
    e != null && e.fetcher && a.setFetcher(e.fetcher), await a.loadFonts(u, t);
  };
  return r._preloadRemoteFontOptions = e, r;
}
function Qe({ byFamily: n }) {
  return async (e, { builder: t }) => {
    const r = performance.now();
    if ("queryLocalFonts" in window) {
      const s = await window.queryLocalFonts();
      n = n ?? [];
      for (const o of s) {
        if (!n.includes(o.family))
          continue;
        const a = await (await o.blob()).arrayBuffer();
        await t.add_raw_font(new Uint8Array(a));
      }
    }
    const i = performance.now();
    console.log("preload system font time used:", i - r);
  };
}
function le(n) {
  return async (e, { builder: t }) => new Promise((r) => {
    t.set_package_registry(n, function(i) {
      return n.resolve(i, this);
    }), r();
  });
}
function je(n) {
  return async (e, t) => {
    var r;
    if (t.alreadySetAccessModel)
      throw new Error(
        `already set some assess model before: ${(r = t.alreadySetAccessModel.constructor) == null ? void 0 : r.name}(${t.alreadySetAccessModel})`
      );
    return t.alreadySetAccessModel = n, new Promise((i) => {
      t.builder.set_access_model(
        n,
        (s) => {
          const o = n.getMTime(s);
          return o ? o.getTime() : 0;
        },
        (s) => n.isFile(s) || !1,
        (s) => n.getRealPath(s) || s,
        (s) => n.readAll(s)
      ), i();
    });
  };
}
class ur {
  constructor(e, t) {
    l(this, "fullyCached");
    l(this, "mTimes", /* @__PURE__ */ new Map());
    l(this, "mRealPaths", /* @__PURE__ */ new Map());
    l(this, "mData", /* @__PURE__ */ new Map());
    this.root = e, e.endsWith("/") && (this.root = this.root.slice(0, this.root.length - 1)), t != null && t.polyfillHeadRequest, this.fullyCached = !!(t != null && t.fullyCached);
  }
  reset() {
    this.mTimes.clear(), this.mRealPaths.clear(), this.mData.clear();
  }
  resolvePath(e) {
    return this.root + e;
  }
  insertFile(e, t, r) {
    this.mTimes.set(e, r), this.mData.set(e, t);
  }
  removeFile(e) {
    this.mTimes.delete(e), this.mData.delete(e);
  }
  async getPreloadScript() {
    const e = [];
    e.push("((async () => {"), e.push(
      "const snapshot = {  root: '', mTimes: new Map(),  mRealPaths: new Map(),  mData: [],};"
    ), e.push("const runFetch = async (path) => {"), e.push("  const res = await fetch(snapshot.root + path);"), e.push("  const buffer = await res.arrayBuffer();"), e.push("  return [path, new Uint8Array(buffer)];"), e.push("};"), e.push(`snapshot.root = ${JSON.stringify(this.root)};`), e.push(
      `snapshot.mTimes = new Map([${[...this.mTimes.entries()].map(([r, i]) => `[${JSON.stringify(r)}, ${(i == null ? void 0 : i.getTime()) || "undefined"}]`).join(", ")}]);`
    ), e.push(
      `snapshot.mRealPaths = new Map([${[...this.mRealPaths.entries()].map(([r, i]) => `[${JSON.stringify(r)}, ${JSON.stringify(i)}]`).join(", ")}]);`
    );
    const t = await Promise.all(
      [...this.mData.entries()].map(async ([r, i]) => (r = JSON.stringify(r), i ? `runFetch(${r})` : `Promise.resolve([${r}, undefined])`))
    );
    return e.push(`snapshot.mData = await Promise.all([${t.join(", ")}]);`), e.push("return snapshot;"), e.push("})())"), e.join(`
`);
  }
  getLastModified(e) {
    const t = new XMLHttpRequest();
    return t.open("HEAD", e, !1), t.send(null), t.status === 200 ? t.getResponseHeader("Last-Modified") : null;
  }
  getMTimeInternal(e) {
    const t = this.getLastModified(this.resolvePath(e));
    if (t)
      return new Date(t);
  }
  getMTime(e) {
    if (e.startsWith("/@memory/"))
      return this.mTimes.has(e) ? this.mTimes.get(e) : void 0;
    if (!this.fullyCached)
      return this.getMTimeInternal(e);
    if (this.mTimes.has(e))
      return this.mTimes.get(e);
    const t = this.getMTimeInternal(e);
    return this.mTimes.set(e, t), t;
  }
  // todo: isFile
  isFile() {
    return !0;
  }
  // todo: getRealPath
  getRealPath(e) {
    return e;
  }
  readAllInternal(e) {
    const t = new XMLHttpRequest();
    if (t.overrideMimeType("text/plain; charset=x-user-defined"), t.open("GET", this.resolvePath(e), !1), t.send(null), t.status === 200 && (t.response instanceof String || typeof t.response == "string"))
      return Uint8Array.from(t.response, (r) => r.charCodeAt(0));
  }
  readAll(e) {
    if (e.startsWith("/@memory/"))
      return this.mData.has(e) ? this.mData.get(e) : void 0;
    if (!this.fullyCached)
      return this.readAllInternal(e);
    if (this.mData.has(e))
      return this.mData.get(e);
    const t = this.readAllInternal(e);
    return this.mData.set(e, t), t;
  }
}
class Be {
  constructor() {
    l(this, "mTimes", /* @__PURE__ */ new Map());
    l(this, "mData", /* @__PURE__ */ new Map());
  }
  reset() {
    this.mTimes.clear(), this.mData.clear();
  }
  insertFile(e, t, r) {
    this.mTimes.set(e, r), this.mData.set(e, t);
  }
  removeFile(e) {
    this.mTimes.delete(e), this.mData.delete(e);
  }
  getMTime(e) {
    if (e.startsWith("/@memory/") && this.mTimes.has(e))
      return this.mTimes.get(e);
  }
  isFile() {
    return !0;
  }
  getRealPath(e) {
    return e;
  }
  readAll(e) {
    if (e.startsWith("/@memory/") && this.mData.has(e))
      return this.mData.get(e);
  }
}
class We {
  constructor(e) {
    l(this, "cache", /* @__PURE__ */ new Map());
    this.am = e;
  }
  resolvePath(e) {
    return `https://packages.typst.org/preview/${e.name}-${e.version}.tar.gz`;
  }
  pullPackageData(e) {
    const t = new XMLHttpRequest();
    if (t.overrideMimeType("text/plain; charset=x-user-defined"), t.open("GET", this.resolvePath(e), !1), t.send(null), t.status === 200 && (t.response instanceof String || typeof t.response == "string"))
      return Uint8Array.from(t.response, (r) => r.charCodeAt(0));
  }
  resolve(e, t) {
    if (e.namespace !== "preview")
      return;
    const r = this.resolvePath(e);
    if (this.cache.has(r))
      return this.cache.get(r)();
    const i = this.pullPackageData(e);
    if (!i)
      return;
    const s = `/@memory/fetch/packages/preview/${e.namespace}/${e.name}/${e.version}`, o = [];
    t.untar(i, (u, d, f) => {
      o.push([s + "/" + u, d, new Date(f)]);
    });
    const a = () => {
      for (const [u, d, f] of o)
        this.am.insertFile(u, d, f);
      return s;
    };
    return this.cache.set(r, a), a();
  }
}
function dr(n) {
  return Math.random().toString(36).replace("0.", "");
}
const lr = (
  // @ts-ignore
  typeof process < "u" && process.versions != null && process.versions.node != null
);
class U {
  /**
   * Create a new instance of {@link TypstSnippet}.
   * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
   * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
   *
   * @example
   *
   * Passes a global shared compiler instance that get initialized lazily:
   * ```typescript
   * const $typst = new TypstSnippet(() => {
   *  return createGlobalCompiler(createTypstCompiler, initOptions);
   * });
   *
   */
  constructor(e) {
    /** @internal */
    l(this, "mainFilePath");
    /** @internal */
    l(this, "cc");
    /** @internal */
    l(this, "ex");
    l(this, "providers");
    /** @internal */
    l(this, "ccOptions");
    /** @internal */
    l(this, "exOptions");
    this.cc = e == null ? void 0 : e.compiler, this.ex = e == null ? void 0 : e.renderer, this.mainFilePath = "/main.typ", this.providers = [];
  }
  /**
   * Set lazy initialized compiler instance for the utility instance.
   * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
   */
  setCompiler(e) {
    this.cc = e;
  }
  /**
   * Get an initialized compiler instance from the utility instance.
   */
  async getCompiler() {
    return typeof this.cc == "function" ? this.cc = await this.cc() : this.cc;
  }
  /**
   * Set lazy initialized renderer instance for the utility instance.
   * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
   */
  setRenderer(e) {
    this.ex = e;
  }
  /**
   * Get an initialized renderer instance from the utility instance.
   */
  async getRenderer() {
    return typeof this.ex == "function" ? this.ex = await this.ex() : this.ex;
  }
  /**
   * add providers for bullding the compiler or renderer component.
   */
  use(...e) {
    if (!this.providers)
      throw new Error("already prepare uses for instances");
    this.providers.push(...e);
  }
  /**
   * Set accessl model for the compiler instance
   * @example
   *
   * use memory access model
   *
   * ```typescript
   * const m = new MemoryAccessModel();
   * $typst.use(TypstSnippet.withAccessModel(m));
   * ```
   */
  static withAccessModel(e) {
    return {
      key: "access-model",
      forRoles: ["compiler"],
      provides: [je(e)]
    };
  }
  /**
   * Set package registry for the compiler instance
   * @example
   *
   * use a customized package registry
   *
   * ```typescript
   * const n = new NodeFetchPackageRegistry();
   * $typst.use(TypstSnippet.withPackageRegistry(n));
   * ```
   */
  static withPackageRegistry(e) {
    return {
      key: "package-registry",
      forRoles: ["compiler"],
      provides: [le(e)]
    };
  }
  /**
   * Retrieve an access model to store the data of fetched files.
   * Provide a PackageRegistry instance for the compiler instance.
   *
   * @example
   *
   * use default (memory) access model
   *
   * ```typescript
   * $typst.use(await TypstSnippet.fetchPackageRegistry());
   * ```
   *
   * @example
   *
   * use external access model
   *
   * ```typescript
   * const m = new MemoryAccessModel();
   * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageRegistry(m));
   * ```
   */
  static fetchPackageRegistry(e) {
    const t = e || new Be(), r = [
      ...e ? [] : [je(t)],
      le(new We(t))
    ];
    return {
      key: "package-registry$fetch",
      forRoles: ["compiler"],
      provides: r
    };
  }
  /**
   * Retrieve a fetcher for fetching package data.
   * Provide a PackageRegistry instance for the compiler instance.
   * @example
   *
   * use a customized fetcher
   *
   * ```typescript
   * import request from 'sync-request-curl';
   * const m = new MemoryAccessModel();
   * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageBy(m, (_, httpUrl) => {
   *   const response = request('GET', this.resolvePath(path), {
   *     insecure: true,
   *   });
   *
   *   if (response.statusCode === 200) {
   *     return response.getBody(undefined);
   *   }
   *   return undefined;
   * }));
   * ```
   */
  static fetchPackageBy(e, t) {
    class r extends We {
      pullPackageData(s) {
        return t(s, this.resolvePath(s));
      }
    }
    return {
      key: "package-registry$lambda",
      forRoles: ["compiler"],
      provides: [le(new r(e))]
    };
  }
  /**
   * Set compiler init options for initializing global instance {@link $typst}.
   * See {@link InitOptions}.
   */
  setCompilerInitOptions(e) {
    this.requireIsUninitialized("compiler", this.cc, U.$buildC), this.ccOptions = e;
  }
  /**
   * Set renderer init options for initializing global instance {@link $typst}.
   * See {@link InitOptions}.
   */
  setRendererInitOptions(e) {
    this.requireIsUninitialized("renderer", this.ex, U.$buildR), this.exOptions = e;
  }
  /**
   * Set shared main file path.
   */
  setMainFilePath(e) {
    this.mainFilePath = e;
  }
  /**
   * Get shared main file path.
   */
  getMainFilePath() {
    return this.mainFilePath;
  }
  removeTmp(e) {
    return e.mainFilePath.startsWith("/tmp/") ? this.unmapShadow(e.mainFilePath) : Promise.resolve();
  }
  /**
   * Add a source file to the compiler.
   * See {@link TypstCompiler#addSource}.
   */
  async addSource(e, t) {
    (await this.getCompiler()).addSource(e, t);
  }
  /**
   * Reset the shadow files.
   * Note: this function is independent to the {@link reset} function.
   * See {@link TypstCompiler#resetShadow}.
   */
  async resetShadow() {
    (await this.getCompiler()).resetShadow();
  }
  /**
   * Add a shadow file to the compiler.
   * See {@link TypstCompiler#mapShadow}.
   */
  async mapShadow(e, t) {
    (await this.getCompiler()).mapShadow(e, t);
  }
  /**
   * Remove a shadow file from the compiler.
   * See {@link TypstCompiler#unmapShadow}.
   */
  async unmapShadow(e) {
    (await this.getCompiler()).unmapShadow(e);
  }
  /**
   * Compile the document to vector (IR) format.
   * See {@link SweetCompileOptions}.
   */
  async vector(e) {
    const t = await this.getCompileOptions(e);
    return (await this.getCompiler()).compile(t).then((r) => r.result).finally(() => this.removeTmp(t));
  }
  /**
   * Compile the document to PDF format.
   * See {@link SweetCompileOptions}.
   */
  async pdf(e) {
    const t = await this.getCompileOptions(e);
    return t.format = "pdf", (await this.getCompiler()).compile(t).then((r) => r.result).finally(() => this.removeTmp(t));
  }
  /**
   * Compile the document to SVG format.
   * See {@link SweetRenderOptions} and {@link RenderSvgOptions}.
   */
  async svg(e) {
    return this.transientRender(
      e,
      (t, r) => t.renderSvg({
        ...e,
        renderSession: r
      })
    );
  }
  /**
   * Compile the document to canvas operations.
   * See {@link SweetRenderOptions} and {@link RenderToCanvasOptions}.
   */
  async canvas(e, t) {
    return this.transientRender(
      t,
      (r, i) => r.renderToCanvas({
        container: e,
        ...t,
        renderSession: i
      })
    );
  }
  /**
   * Get semantic tokens for the document.
   */
  async query(e) {
    const t = await this.getCompileOptions(e);
    return (await this.getCompiler()).query({
      ...e,
      ...t
    }).finally(() => this.removeTmp(t));
  }
  /**
   * Get token legend for semantic tokens.
   */
  async getSemanticTokenLegend() {
    return (await this.getCompiler()).getSemanticTokenLegend();
  }
  /**
   * Get semantic tokens for the document.
   * See {@link SweetCompileOptions}.
   * See {@link TypstCompiler#getSemanticTokens}.
   */
  async getSemanticTokens(e) {
    const t = await this.getCompileOptions(e);
    return (await this.getCompiler()).getSemanticTokens({
      mainFilePath: t.mainFilePath,
      resultId: e.resultId
    }).finally(() => this.removeTmp(t));
  }
  async getCompileOptions(e) {
    if (e === void 0)
      return { mainFilePath: this.mainFilePath, diagnostics: "none" };
    if (typeof e == "string")
      throw new Error("please specify opts as {mainContent: '...'} or {mainFilePath: '...'}");
    if ("mainFilePath" in e)
      return { ...e, diagnostics: "none" };
    {
      const t = `/tmp/${dr()}.typ`;
      return await this.addSource(t, e.mainContent), { mainFilePath: t, inputs: e.inputs, diagnostics: "none" };
    }
  }
  async getVector(e) {
    if (e && "vectorData" in e)
      return e.vectorData;
    const t = await this.getCompileOptions(e);
    return (await this.getCompiler()).compile(t).then((r) => r.result).finally(() => this.removeTmp(t));
  }
  async transientRender(e, t) {
    const r = await this.getRenderer();
    if (!r)
      throw new Error("does not provide renderer instance");
    const i = await this.getVector(e);
    return await r.runWithSession(async (s) => (r.manipulateData({
      renderSession: s,
      action: "reset",
      data: i
    }), t(r, s)));
  }
  async prepareUse() {
    if (!this.providers)
      return;
    const e = await Promise.all(
      this.providers.map((a) => typeof a == "function" ? a() : a)
    );
    if (this.providers = [], ge == this && !e.some((a) => a.key.includes("package-registry") || a.key.includes("access-model")))
      if (lr) {
        const a = new Function("m", "return import(m)");
        try {
          const u = new Be(), { default: d } = await a("sync-request");
          ge.use(
            U.withAccessModel(u),
            U.fetchPackageBy(u, (f, w) => {
              const x = d("GET", w);
              if (x.statusCode === 200)
                return x.getBody(void 0);
            })
          );
        } catch {
        }
      } else
        ge.use(U.fetchPackageRegistry());
    const t = await Promise.all(
      this.providers.map((a) => typeof a == "function" ? a() : a)
    ), r = this.ccOptions || (this.ccOptions = {}), i = r.beforeBuild || (r.beforeBuild = []), s = this.exOptions || (this.exOptions = {}), o = s.beforeBuild || (s.beforeBuild = []);
    for (const a of [...e, ...t])
      a.forRoles.includes("compiler") && (this.requireIsUninitialized("compiler", this.cc, U.$buildC), i.push(...a.provides)), a.forRoles.includes("renderer") && (this.requireIsUninitialized("renderer", this.ex, U.$buildR), o.push(...a.provides));
    this.providers = void 0;
  }
  requireIsUninitialized(e, t, r) {
    if (typeof t != "function")
      throw new Error(`${e} has been initialized: ${t}`);
    if (r && t != r)
      throw new Error(`${e} instance is set to non default value`);
  }
  /** @internal */
  static async $buildC() {
    const { createGlobalCompiler: e } = await Promise.resolve().then(() => Br), { createTypstCompiler: t } = await Promise.resolve().then(() => Gr);
    return await this.prepareUse(), e(t, this.ccOptions);
  }
  /** @internal */
  static async $buildR() {
    const { createGlobalRenderer: e } = await Promise.resolve().then(() => Xr), { createTypstRenderer: t } = await Promise.resolve().then(() => cn);
    return await this.prepareUse(), e(t, this.exOptions);
  }
}
const ge = new U({
  compiler: U.$buildC,
  renderer: U.$buildR
}), E = Symbol.for("reflexo-obj");
var Ve = /* @__PURE__ */ ((n) => (n[n.PIXEL_PER_PT = 3] = "PIXEL_PER_PT", n))(Ve || {});
let It = class {
  constructor(e, t, r) {
    l(this, "loadPageCount");
    l(this, "imageScaleFactor");
    l(this, "container");
    l(this, "canvasList");
    l(this, "textLayerList");
    l(this, "commonList");
    l(this, "textLayerParentList");
    l(this, "semanticLayerList");
    this.pageInfos = e, this.imageScaleFactor = r.pixelPerPt ?? Ve.PIXEL_PER_PT, t.innerHTML = "", t.style.width = "100%", this.container = t, this.canvasList = new Array(this.loadPageCount), this.textLayerList = new Array(this.loadPageCount), this.commonList = new Array(this.loadPageCount), this.textLayerParentList = new Array(this.loadPageCount), this.semanticLayerList = new Array(this.loadPageCount);
    const i = (s, o, a) => {
      const u = Math.ceil(o.width) * this.imageScaleFactor, d = Math.ceil(o.height) * this.imageScaleFactor, f = this.canvasList[s] = document.createElement("canvas"), w = this.semanticLayerList[s] = document.createElement("div"), x = this.textLayerList[s] = document.createElement("div"), C = this.textLayerParentList[s] = document.createElement("div");
      if (f.getContext("2d")) {
        const A = document.createElement("div");
        f.width = u, f.height = d, A.appendChild(f), a.appendChild(A), A.style.position = "absolute";
      }
      {
        C.appendChild(x), C.className = "typst-html-semantics";
        const A = t.offsetWidth, $ = A / o.width;
        C.style.width = `${A}px`, C.style.height = `${o.height * $}px`, C.style.setProperty("--data-text-width", `${$}px`), C.style.setProperty("--data-text-height", `${$}px`), a.classList.add("typst-page"), a.classList.add("canvas"), a.style.width = `${A}px`, a.style.height = `${d * $}px`, a.style.position = "relative", w.appendChild(C), a.appendChild(w);
      }
    };
    for (let s = 0; s < this.pageInfos.length; s++) {
      const o = this.pageInfos[s];
      let a;
      a = this.commonList[s] = document.createElement("div"), t.appendChild(a), i(s, o, a);
    }
  }
  resetLayout() {
    for (let e = 0; e < this.pageInfos.length; e++) {
      const t = this.pageInfos[e], r = Math.ceil(t.width) * this.imageScaleFactor, i = Math.ceil(t.height) * this.imageScaleFactor, s = this.canvasList[e].parentElement;
      if (!s)
        throw new Error(
          `canvasDiv is null for page ${e}, canvas list length ${this.canvasList.length}`
        );
      const o = this.commonList[e], a = this.textLayerParentList[e], u = this.container.offsetWidth, d = u / r;
      a.style.width = `${u}px`, a.style.height = `${i * d}px`, o.style.width = `${u}px`, o.style.height = `${i * d}px`;
      const f = this.container.offsetWidth / r;
      s.style.transformOrigin = "0px 0px", s.style.transform = `scale(${f})`;
    }
  }
};
const gr = (n) => {
  let e = !1, t;
  return () => e ? t : (e = !0, t = n());
};
let Mt = class {
  constructor(e) {
    l(this, "wasmBin");
    l(this, "initOnce");
    if (typeof e != "function")
      throw new Error("initFn is not a function");
    this.initOnce = gr(async () => {
      await e(this.wasmBin);
    });
  }
  async init(e) {
    this.wasmBin = e, await this.initOnce();
  }
};
const fr = (n, e) => e.some((t) => n instanceof t);
let Xe, Ye;
function wr() {
  return Xe || (Xe = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function hr() {
  return Ye || (Ye = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const Lt = /* @__PURE__ */ new WeakMap(), ze = /* @__PURE__ */ new WeakMap(), At = /* @__PURE__ */ new WeakMap(), Ee = /* @__PURE__ */ new WeakMap(), Je = /* @__PURE__ */ new WeakMap();
function pr(n) {
  const e = new Promise((t, r) => {
    const i = () => {
      n.removeEventListener("success", s), n.removeEventListener("error", o);
    }, s = () => {
      t(se(n.result)), i();
    }, o = () => {
      r(n.error), i();
    };
    n.addEventListener("success", s), n.addEventListener("error", o);
  });
  return e.then((t) => {
    t instanceof IDBCursor && Lt.set(t, n);
  }).catch(() => {
  }), Je.set(e, n), e;
}
function br(n) {
  if (ze.has(n))
    return;
  const e = new Promise((t, r) => {
    const i = () => {
      n.removeEventListener("complete", s), n.removeEventListener("error", o), n.removeEventListener("abort", o);
    }, s = () => {
      t(), i();
    }, o = () => {
      r(n.error || new DOMException("AbortError", "AbortError")), i();
    };
    n.addEventListener("complete", s), n.addEventListener("error", o), n.addEventListener("abort", o);
  });
  ze.set(n, e);
}
let qe = {
  get(n, e, t) {
    if (n instanceof IDBTransaction) {
      if (e === "done")
        return ze.get(n);
      if (e === "objectStoreNames")
        return n.objectStoreNames || At.get(n);
      if (e === "store")
        return t.objectStoreNames[1] ? void 0 : t.objectStore(t.objectStoreNames[0]);
    }
    return se(n[e]);
  },
  set(n, e, t) {
    return n[e] = t, !0;
  },
  has(n, e) {
    return n instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in n;
  }
};
function mr(n) {
  qe = n(qe);
}
function yr(n) {
  return n === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...t) {
    const r = n.call(Pe(this), e, ...t);
    return At.set(r, e.sort ? e.sort() : [e]), se(r);
  } : hr().includes(n) ? function(...e) {
    return n.apply(Pe(this), e), se(Lt.get(this));
  } : function(...e) {
    return se(n.apply(Pe(this), e));
  };
}
function vr(n) {
  return typeof n == "function" ? yr(n) : (n instanceof IDBTransaction && br(n), fr(n, wr()) ? new Proxy(n, qe) : n);
}
function se(n) {
  if (n instanceof IDBRequest)
    return pr(n);
  if (Ee.has(n))
    return Ee.get(n);
  const e = vr(n);
  return e !== n && (Ee.set(n, e), Je.set(e, n)), e;
}
const Pe = (n) => Je.get(n), Sr = ["get", "getKey", "getAll", "getAllKeys", "count"], Cr = ["put", "add", "delete", "clear"], Ie = /* @__PURE__ */ new Map();
function Ze(n, e) {
  if (!(n instanceof IDBDatabase && !(e in n) && typeof e == "string"))
    return;
  if (Ie.get(e))
    return Ie.get(e);
  const t = e.replace(/FromIndex$/, ""), r = e !== t, i = Cr.includes(t);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(t in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || Sr.includes(t))
  )
    return;
  const s = async function(o, ...a) {
    const u = this.transaction(o, i ? "readwrite" : "readonly");
    let d = u.store;
    return r && (d = d.index(a.shift())), (await Promise.all([
      d[t](...a),
      i && u.done
    ]))[0];
  };
  return Ie.set(e, s), s;
}
mr((n) => ({
  ...n,
  get: (e, t, r) => Ze(e, t) || n.get(e, t, r),
  has: (e, t) => !!Ze(e, t) || n.has(e, t)
}));
let xr = class {
  constructor() {
    l(this, "loadedFonts", /* @__PURE__ */ new Set());
    l(this, "fetcher", fetch);
  }
  setFetcher(e) {
    this.fetcher = e;
  }
  async loadFonts(e, t) {
    const r = new Function("m", "return import(m)"), i = this.fetcher || (this.fetcher = await async function() {
      const { fetchBuilder: a, FileSystemCache: u } = await r("node-fetch-cache"), d = new u({
        /// By default, we don't have a complicated cache policy.
        cacheDirectory: ".cache/typst/fonts"
      }), f = a.withCache(d);
      return function(w, x) {
        const C = setTimeout(() => {
          console.warn("font fetching is stucking:", w);
        }, 15e3);
        return f(w, x).finally(() => {
          clearTimeout(C);
        });
      };
    }()), s = t.filter((a) => a instanceof Uint8Array ? !0 : this.loadedFonts.has(a) ? !1 : (this.loadedFonts.add(a), !0)), o = await Promise.all(
      s.map(async (a) => {
        if (a instanceof Uint8Array) {
          await e.add_raw_font(a);
          return;
        }
        return new Uint8Array(await (await i(a)).arrayBuffer());
      })
    );
    for (const a of o)
      a && await e.add_raw_font(a);
  }
  async build(e, t, r) {
    const i = { ref: this, builder: t, hooks: r };
    for (const o of (e == null ? void 0 : e.beforeBuild) ?? [])
      await o(void 0, i);
    return r.latelyBuild && r.latelyBuild(i), await t.build();
  }
};
async function Tt(n, e, t, r) {
  var i;
  return await e.init((i = n == null ? void 0 : n.getModule) == null ? void 0 : i.call(n)), await new xr().build(n, new t(), r);
}
let kr = class Ot {
  constructor(e) {
    l(this, "hookedElem");
    l(this, "kModule");
    l(this, "opts");
    l(this, "modes", []);
    /// Configuration fields
    /// enable partial rendering
    l(this, "partialRendering", !0);
    /// underlying renderer
    l(this, "renderMode", "svg");
    l(this, "r");
    /// preview mode
    l(this, "previewMode", 0);
    /// whether this is a content preview
    l(this, "isContentPreview", !1);
    /// whether this content preview will mix outline titles
    l(this, "isMixinOutline", !1);
    /// background color
    l(this, "backgroundColor", "black");
    /// default page color (empty string means transparent)
    l(this, "pageColor", "white");
    /// pixel per pt
    l(this, "pixelPerPt", 3);
    /// customized way to retrieving dom state
    l(this, "retrieveDOMState");
    /// State fields
    /// whether svg is updating (in triggerSvgUpdate)
    l(this, "isRendering", !1);
    /// whether kModule is initialized
    l(this, "moduleInitialized", !1);
    /// patch queue for updating data.
    l(this, "patchQueue", []);
    /// resources to dispose
    l(this, "disposeList", []);
    /// canvas render ctoken
    l(this, "canvasRenderCToken");
    /// There are two scales in this class: The real scale is to adjust the size
    /// of `hookedElem` to fit the svg. The virtual scale (scale ratio) is to let
    /// user zoom in/out the svg. For example:
    /// + the default value of virtual scale is 1, which means the svg is totally
    ///   fit in `hookedElem`.
    /// + if user set virtual scale to 0.5, then the svg will be zoomed out to fit
    ///   in half width of `hookedElem`. "real" current scale of `hookedElem`
    l(this, "currentRealScale", 1);
    /// "virtual" current scale of `hookedElem`
    l(this, "currentScaleRatio", 1);
    /// timeout for delayed viewport change
    l(this, "vpTimeout");
    /// sampled by last render time.
    l(this, "sampledRenderTime", 0);
    /// page to partial render
    l(this, "partialRenderPage", 0);
    /// outline data
    l(this, "outline");
    /// cursor position in form of [page, x, y]
    l(this, "cursorPosition");
    // id: number = rnd++;
    /// Cache fields
    /// cached state of container, default to retrieve state from `this.hookedElem`
    l(this, "cachedDOMState", {
      width: 0,
      height: 0,
      window: {
        innerWidth: 0,
        innerHeight: 0
      },
      boundingRect: {
        left: 0,
        top: 0,
        right: 0
      }
    });
    var t, r;
    this.hookedElem = e.hookedElem, this.kModule = e.kModule, this.opts = e || {};
    {
      const { renderMode: i, previewMode: s, isContentPreview: o, retrieveDOMState: a } = e || {};
      this.partialRendering = !1, this.renderMode = i ?? this.renderMode, this.previewMode = s ?? this.previewMode, this.isContentPreview = o || !1, this.retrieveDOMState = a ?? (() => ({
        width: this.hookedElem.offsetWidth,
        height: this.hookedElem.offsetHeight,
        window: {
          innerWidth: window.innerWidth,
          innerHeight: window.innerHeight
        },
        boundingRect: this.hookedElem.getBoundingClientRect()
      })), this.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue(
        "--typst-preview-background-color"
      );
    }
    this.hookedElem.classList.add("hide-scrollbar-x"), (t = this.hookedElem.parentElement) == null || t.classList.add("hide-scrollbar-x"), this.previewMode === 1 && (this.hookedElem.classList.add("hide-scrollbar-y"), (r = this.hookedElem.parentElement) == null || r.classList.add("hide-scrollbar-y")), this.installCtrlWheelHandler();
  }
  reset() {
    this.kModule.reset(), this.moduleInitialized = !1;
  }
  dispose() {
    const e = this.disposeList;
    this.disposeList = [], e.forEach((t) => t());
  }
  static derive(e, t) {
    return ["rescale", "rerender", "postRender"].reduce((r, i) => (r[i] = e[`${i}$${t}`].bind(e), console.assert(r[i] !== void 0, `${i}$${t} is undefined`), r), {});
  }
  registerMode(e) {
    const t = Ot.derive(this, e);
    this.modes.push([e, t]), e === this.renderMode && (this.r = t);
  }
  installCtrlWheelHandler() {
    const e = [
      0.1,
      0.2,
      0.3,
      0.4,
      0.5,
      0.6,
      0.7,
      0.8,
      0.9,
      1,
      1.1,
      1.3,
      1.5,
      1.7,
      1.9,
      2.1,
      2.4,
      2.7,
      3,
      3.3,
      3.7,
      4.1,
      4.6,
      5.1,
      5.7,
      6.3,
      7,
      7.7,
      8.5,
      9.4,
      10
    ], t = (r) => {
      var i, s, o, a;
      if (r.ctrlKey) {
        r.preventDefault(), this.cachedDOMState = this.retrieveDOMState(), window.onresize !== null && (window.onresize = null);
        const u = this.currentScaleRatio;
        if (r.deltaY < 0) {
          if (this.currentScaleRatio >= e.at(-1))
            return;
          this.currentScaleRatio = e.filter((C) => C > this.currentScaleRatio).at(0);
        } else if (r.deltaY > 0) {
          if (this.currentScaleRatio <= e.at(0))
            return;
          this.currentScaleRatio = e.filter((C) => C < this.currentScaleRatio).at(-1);
        } else
          return;
        const d = this.currentScaleRatio / u, f = r.pageX * (d - 1), w = r.pageY * (d - 1);
        Math.abs(this.currentScaleRatio - 1) < 1e-5 ? (this.hookedElem.classList.add("hide-scrollbar-x"), (i = this.hookedElem.parentElement) == null || i.classList.add("hide-scrollbar-x"), this.previewMode === 1 && (this.hookedElem.classList.add("hide-scrollbar-y"), (s = this.hookedElem.parentElement) == null || s.classList.add("hide-scrollbar-y"))) : (this.hookedElem.classList.remove("hide-scrollbar-x"), (o = this.hookedElem.parentElement) == null || o.classList.remove("hide-scrollbar-x"), this.previewMode === 1 && (this.hookedElem.classList.remove("hide-scrollbar-y"), (a = this.hookedElem.parentElement) == null || a.classList.remove("hide-scrollbar-y")));
        const x = this.hookedElem.firstElementChild;
        if (x) {
          const C = this.getSvgScaleRatio(), F = Number.parseFloat(x.getAttribute("data-height")), A = Math.ceil(F * C);
          this.hookedElem.style.height = `${A * 2}px`;
        }
        return window.scrollBy(f, w), this.addViewportChange(), !1;
      }
    };
    this.renderMode !== "dom" && (typeof acquireVsCodeApi < "u" ? (window.addEventListener("wheel", t, {
      passive: !1
    }), this.disposeList.push(() => {
      window.removeEventListener("wheel", t);
    })) : (document.body.addEventListener("wheel", t, {
      passive: !1
    }), this.disposeList.push(() => {
      document.body.removeEventListener("wheel", t);
    })));
  }
  /// Get current scale from html to svg
  // Note: one should retrieve dom state before rescale
  getSvgScaleRatio() {
    const e = this.hookedElem.firstElementChild;
    if (!e)
      return 0;
    const t = this.cachedDOMState, r = Number.parseFloat(
      e.getAttribute("data-width") || e.getAttribute("width") || "1"
    ), i = Number.parseFloat(
      e.getAttribute("data-height") || e.getAttribute("height") || "1"
    );
    return this.currentRealScale = this.previewMode === 1 ? Math.min(t.width / r, t.height / i) : t.width / r, this.currentRealScale * this.currentScaleRatio;
  }
  processQueue(e) {
    const t = e[0];
    switch (t) {
      case "new":
      case "diff-v1":
        return t === "new" && this.reset(), this.kModule.manipulateData({
          action: "merge",
          data: e[1]
        }), this.moduleInitialized = !0, !0;
      case "viewport-change":
        return this.moduleInitialized ? !0 : (console.log("viewport-change before initialization"), !1);
      default:
        return console.log("svgUpdateEvent", e), !1;
    }
  }
  triggerUpdate() {
    if (this.isRendering)
      return;
    this.isRendering = !0;
    const e = async () => {
      if (this.cachedDOMState = this.retrieveDOMState(), this.patchQueue.length === 0) {
        this.isRendering = !1, this.postprocessChanges();
        return;
      }
      try {
        let t = performance.now();
        const r = this.canvasRenderCToken;
        r && (await r.cancel(), await r.wait(), this.canvasRenderCToken = void 0, console.log("cancel canvas rendering"));
        let i = !1;
        for (; this.patchQueue.length > 0; )
          i = this.processQueue(this.patchQueue.shift()) || i;
        let s = performance.now();
        i && (this.r.rescale(), await this.r.rerender(), this.r.rescale());
        let o = performance.now();
        const a = (u, d, f) => `${u} ${(f - d).toFixed(2)} ms`;
        this.sampledRenderTime = o - t, console.log([a("parse", t, s), a("rerender", s, o), a("total", t, o)].join(", ")), requestAnimationFrame(e);
      } catch (t) {
        console.error(t), this.isRendering = !1, this.postprocessChanges();
      }
    };
    requestAnimationFrame(e);
  }
  postprocessChanges() {
    this.r.postRender(), this.previewMode === 1 && document.querySelectorAll(".typst-page-number-indicator").forEach((e) => {
      e.textContent = `${this.kModule.retrievePagesInfo().length}`;
    });
  }
  addChangement(e) {
    e[0] === "new" && this.patchQueue.splice(0, this.patchQueue.length);
    const t = () => {
      this.vpTimeout = void 0, this.patchQueue.push(e), this.triggerUpdate();
    };
    this.vpTimeout !== void 0 && clearTimeout(this.vpTimeout), e[0] === "viewport-change" && this.isRendering ? this.vpTimeout = setTimeout(t, this.sampledRenderTime || 100) : t();
  }
  addViewportChange() {
    this.addChangement(["viewport-change", ""]);
  }
};
function Rr(n) {
  return class {
    constructor(t) {
      l(this, "impl");
      l(this, "kModule");
      if (t.isContentPreview && (t.renderMode = "canvas"), this.kModule = t.kModule, this.impl = new n(t), !this.impl.r)
        throw new Error(`mode is not supported, ${t == null ? void 0 : t.renderMode}`);
      t.isContentPreview && (this.impl.partialRendering = !0, this.impl.pixelPerPt = 1, this.impl.isMixinOutline = !0);
    }
    dispose() {
      this.impl.dispose();
    }
    reset() {
      this.impl.reset();
    }
    addChangement(t) {
      this.impl.addChangement(t);
    }
    addViewportChange() {
      this.impl.addViewportChange();
    }
    setPageColor(t) {
      this.impl.pageColor = t, this.addViewportChange();
    }
    setPartialRendering(t) {
      this.impl.partialRendering = t;
    }
    setCursor(t, r, i) {
      this.impl.cursorPosition = [t, r, i];
    }
    setPartialPageNumber(t) {
      return t <= 0 || t > this.kModule.retrievePagesInfo().length ? !1 : (this.impl.partialRenderPage = t - 1, this.addViewportChange(), !0);
    }
    getPartialPageNumber() {
      return this.impl.partialRenderPage + 1;
    }
    setOutineData(t) {
      this.impl.outline = t, this.addViewportChange();
    }
  };
}
function Er(n, ...e) {
  return e.reduce((t, r) => r(t), n);
}
let Pr = class {
  constructor() {
    l(this, "isCancellationRequested", !1);
    l(this, "_onCancelled");
    l(this, "_onCancelledResolveResolved");
    let e, t;
    this._onCancelled = new Promise((r) => {
      e = r, t && t(r);
    }), this._onCancelledResolveResolved = new Promise((r) => {
      t = r, e && r(e);
    });
  }
  async cancel() {
    await this._onCancelledResolveResolved, this.isCancellationRequested = !0;
  }
  isCancelRequested() {
    return this.isCancellationRequested;
  }
  async consume() {
    (await this._onCancelledResolveResolved)();
  }
  wait() {
    return this._onCancelled;
  }
};
const Ir = () => new Promise((n) => requestAnimationFrame(n));
function Mr(n) {
  return class extends n {
    constructor(...r) {
      super(...r);
      /// The template element for creating DOM by string.
      l(this, "tmpl", document.createElement("template"));
      /// The stub element for replacing an invisible element.
      l(this, "stub", this.createElement("<stub></stub>"));
      /// Typescript side of lib.
      l(this, "plugin");
      /// Rust side of kernel.
      l(this, "docKernel");
      /// The element to track.
      l(this, "resourceHeader");
      /// Expected exact state of the current DOM.
      /// Initially it is empty meaning no any page is rendered.
      l(this, "pages", []);
      /// The virtual scale of the document.
      l(this, "domScale", 1);
      /// Track mode.
      l(this, "track_mode", 0);
      /// Current executing task.
      l(this, "current_task");
      /// The currently maintained viewport.
      l(this, "viewport");
      if (this.registerMode("dom"), this.disposeList.push(() => {
        this.dispose();
      }), this.plugin = this.opts.renderer, this.opts.domScale !== void 0) {
        if (this.opts.domScale <= 0)
          throw new Error("domScale must be positive");
        this.domScale = this.opts.domScale;
      }
    }
    dispose() {
      for (const r of this.pages)
        r.dispose();
      this.docKernel && this.docKernel.free();
    }
    createElement(r) {
      return this.tmpl.innerHTML = r, this.tmpl.content.firstElementChild;
    }
    async mountDom(r) {
      if (console.log("mountDom", r), this.docKernel)
        throw new Error("already mounted");
      this.hookedElem.innerHTML = '<svg class="typst-svg-resources" viewBox="0 0 0 0" width="0" height="0" style="opacity: 0; position: absolute;"></svg>', this.resourceHeader = this.hookedElem.querySelector(".typst-svg-resources"), this.docKernel = await this.plugin.renderer.mount_dom(this.kModule[E], this.hookedElem), this.docKernel.bind_functions({
        populateGlyphs: (i) => {
          let s = this.createElement(i);
          console.log("populateGlyphs", s);
          let o = s.firstElementChild;
          this.resourceHeader.append(o);
        }
      });
    }
    async cancelAnyway$dom() {
      if (console.log("cancelAnyway$dom"), this.current_task) {
        const r = this.current_task;
        this.current_task = void 0, await r.cancel();
      }
    }
    retrieveDOMPages() {
      return Array.from(this.hookedElem.querySelectorAll(".typst-dom-page"));
    }
    // doesn't need to postRender
    postRender$dom() {
    }
    // doesn't need to rescale
    rescale$dom() {
    }
    getDomViewport(r, i) {
      const s = i.left, o = -i.top, a = i.right, u = r.innerHeight - i.top, d = {
        x: 0,
        y: o / this.domScale,
        width: Math.max(a - s, 0) / this.domScale,
        height: Math.max(u - o, 0) / this.domScale
      };
      return (d.width <= 0 || d.height <= 0) && (d.x = d.y = d.width = d.height = 0), d;
    }
    // fast mode
    async rerender$dom() {
      const r = this.retrieveDOMState(), { x: i, y: s, width: o, height: a } = this.getDomViewport(r.window, r.boundingRect);
      if (!await this.docKernel.relayout(i, s, o, a))
        return;
      const d = new Pr();
      this.doRender$dom(d), this.current_task = d;
    }
    async doRender$dom(r) {
      const i = (u, d) => {
        if (u && !r.isCancelRequested() && d)
          return d();
      }, s = this.retrieveDOMPages().map((u) => {
        const { innerWidth: d, innerHeight: f } = window, w = u.getBoundingClientRect();
        return {
          inWindow: !(w.left > d || w.right < 0 || w.top > f || w.bottom < 0),
          page: u
        };
      }), o = async (u) => {
        if (await Ir(), r.isCancelRequested()) {
          console.log("cancel stage", 0, u);
          return;
        }
        const d = s[u].page, f = d.getBoundingClientRect(), w = this.getDomViewport(window, f), x = (D) => this.docKernel.need_repaint(u, w.x, w.y, w.width, w.height, D), C = (D) => this.docKernel.repaint(u, w.x, w.y, w.width, w.height, D), F = (D) => {
          if (!r.isCancelRequested())
            return i(x(D), () => C(D));
        };
        await F(
          0
          /* Layout */
        );
        const A = (f.width ? Number.parseFloat(d.getAttribute("data-width")) / f.width : 1) * this.domScale, $ = (f.height ? Number.parseFloat(d.getAttribute("data-height")) / f.height : 1) * this.domScale;
        if (w.x *= A, w.y *= $, w.y -= 100, w.width *= A, w.height *= $, w.height += 200, await F(
          1
          /* Svg */
        ), await F(
          2
          /* Semantics */
        ), r.isCancelRequested()) {
          console.log("cancel stage", 2, u);
          return;
        }
        x(
          3
          /* PrepareCanvas */
        ) ? (async () => {
          if (await C(
            3
            /* PrepareCanvas */
          ), !r.isCancelRequested())
            return F(
              4
              /* Canvas */
            );
        })() : await F(
          4
          /* Canvas */
        );
      }, a = async (u) => {
        for (let d = 0; d < s.length; ++d) {
          if (r.isCancelRequested()) {
            console.log("cancel page", 0, d);
            return;
          }
          s[d].inWindow === u && await o(d);
        }
      };
      this.cancelAnyway$dom(), await a(!0), await a(!1), !r.isCancelRequested() && console.log(
        "finished",
        0
        /* Layout */
      );
    }
  };
}
let Lr = class extends Rr(
  Er(
    kr,
    Mr
  )
) {
};
var Ct;
let Me = (Ct = E, class {
  /**
   * @internal
   */
  constructor(e, t) {
    /**
     * @internal
     */
    l(this, Ct);
    this.plugin = e, this[E] = t;
  }
  /**
   * @deprecated set in {@link RenderToCanvasOptions} instead
   *
   * Set the background color of the Typst document.
   * @param {string} t - The background color in format of `^#?[0-9a-f]{6}$`
   *
   * Note: Default to `#ffffff`.
   *
   * Note: Only available in canvas rendering mode.
   */
  set backgroundColor(e) {
    e !== void 0 && (this[E].background_color = e);
  }
  /**
   * Get the background color of the Typst document.
   *
   * Note: Default to `#ffffff`.
   *
   * Note: Only available in canvas rendering mode.
   */
  get backgroundColor() {
    return this[E].background_color;
  }
  /**
   * Set the pixel per point scale up the canvas panel.
   *
   * Note: Default to `3`.
   *
   * Note: Only available in canvas rendering mode.
   */
  set pixelPerPt(e) {
    e !== void 0 && (this[E].pixel_per_pt = e);
  }
  /**
   * @deprecated set in {@link RenderToCanvasOptions} instead
   *
   * Get the pixel per point scale up the canvas panel.
   *
   * Note: Default to `3`.
   *
   * Note: Only available in canvas rendering mode.
   */
  get pixelPerPt() {
    return this[E].pixel_per_pt;
  }
  /**
   * Reset state
   */
  reset() {
    this.plugin.resetSession(this);
  }
  /**
   * @deprecated
   * use {@link docWidth} instead
   */
  get doc_width() {
    return this[E].doc_width;
  }
  get docWidth() {
    return this[E].doc_width;
  }
  /**
   * @deprecated
   * use {@link docHeight} instead
   */
  get doc_height() {
    return this[E].doc_height;
  }
  get docHeight() {
    return this[E].doc_height;
  }
  retrievePagesInfo() {
    const e = this[E].pages_info, t = [], r = e.page_count;
    for (let i = 0; i < r; i++) {
      const s = e.page(i);
      t.push({
        pageOffset: s.page_off,
        width: s.width_pt,
        height: s.height_pt
      });
    }
    return t;
  }
  getSourceLoc(e) {
    return this[E].source_span(e);
  }
  /**
   * See {@link TypstRenderer#renderSvg} for more details.
   */
  renderSvg(e) {
    return this.plugin.renderSvg({
      renderSession: this,
      ...e
    });
  }
  /**
   * See {@link TypstRenderer#renderToSvg} for more details.
   */
  renderToSvg(e) {
    return this.plugin.renderToSvg({
      renderSession: this,
      ...e
    });
  }
  /**
   * See {@link TypstRenderer#renderCanvas} for more details.
   */
  renderCanvas(e) {
    return this.plugin.renderCanvas({
      renderSession: this,
      ...e
    });
  }
  /**
   * See {@link TypstRenderer#manipulateData} for more details.
   */
  manipulateData(e) {
    this.plugin.manipulateData({
      renderSession: this,
      ...e
    });
  }
  /**
   * See {@link TypstRenderer#renderSvgDiff} for more details.
   */
  renderSvgDiff(e) {
    return this.plugin.renderSvgDiff({
      renderSession: this,
      ...e
    });
  }
  /**
   * @deprecated
   * use {@link getSourceLoc} instead
   */
  get_source_loc(e) {
    return this[E].source_span(e);
  }
  /**
   * @deprecated
   * use {@link renderSvgDiff} instead
   */
  render_in_window(e, t, r, i) {
    return this[E].render_in_window(e, t, r, i);
  }
  /**
   * @deprecated
   * use {@link manipulateData} instead
   */
  merge_delta(e) {
    this.plugin.manipulateData({
      renderSession: this,
      action: "merge",
      data: e
    });
  }
});
var xt;
let Ar = (xt = E, class {
  /**
   * @internal
   */
  constructor(e, t) {
    /**
     * @internal
     */
    l(this, xt);
    /**
     * @internal
     */
    l(this, "managedCanvasElemList", /* @__PURE__ */ new Map());
    /**
     * @internal
     */
    l(this, "canvasCounter", Math.random());
    this.plugin = e, this[E] = t;
  }
  /**
   * See {@link TypstRenderer#manipulateData} for more details.
   */
  manipulateData(e, t) {
    return this[E].manipulate_data(e, t);
  }
  /**
   * You must submit all canvas in pages to ensure synchronization with the background worker
   *
   * See {@link TypstRenderer#renderCanvas} for more details.
   */
  renderCanvas(e) {
    const t = this.managedCanvasElemList;
    for (const [a, u] of t)
      u[0] = 0;
    for (const a of e) {
      const u = a.canvas;
      let d = u.dataset.manageId, f = 2;
      d || (d = this.canvasCounter.toFixed(5), this.canvasCounter += 1, u.dataset.manageId = d, f = 1);
      let w = t.get(d);
      if (w && w[0] !== 0)
        throw new Error("cannot update a canvas for two times in batch");
      t.set(d, [f, { ...a }]);
    }
    const r = Array.from(t.entries()), i = new Uint8Array(r.length), s = new Array(r.length), o = r.map(([a, [u, d]], f) => (u || t.delete(a), i[f] = u, s[f] = d.canvas, this.plugin.canvasOptionsToRust(d)));
    return this[E].render_canvas(i, s, o);
  }
  async retrievePagesInfo() {
    const e = await this[E].get_pages_info();
    console.log(e);
    const t = [], r = e.page_count;
    for (let i = 0; i < r; i++) {
      const s = e.page(i);
      t.push({
        pageOffset: s.page_off,
        width: s.width_pt,
        height: s.height_pt
      });
    }
    return t;
  }
});
const Tr = (n) => new Mt(async (e) => await n.default(e));
function et() {
  return new Ft();
}
function Xn() {
  return new Ft();
}
async function Yn() {
  return (await Promise.resolve().then(() => Ge)).renderer_build_info();
}
let tt = !0, Ft = class {
  constructor() {
    l(this, "renderer");
    l(this, "rendererJs");
  }
  async init(e) {
    var r;
    this.rendererJs = await (((r = e == null ? void 0 : e.getWrapper) == null ? void 0 : r.call(e)) || Promise.resolve().then(() => Ge));
    const t = this.rendererJs.TypstRendererBuilder;
    this.renderer = await Tt(
      e,
      Tr(this.rendererJs),
      t,
      {}
    );
  }
  loadGlyphPack(e) {
    return Promise.resolve();
  }
  createOptionsToRust(e) {
    const t = new this.rendererJs.CreateSessionOptions();
    return e.format !== void 0 && (t.format = e.format), e.artifactContent !== void 0 && (t.artifact_content = e.artifactContent), t;
  }
  canvasOptionsToRust(e) {
    const t = new this.rendererJs.RenderPageImageOptions();
    if (e.pageOffset === void 0)
      throw new Error("pageOffset is required in reflexo v0.5.0");
    if (t.page_off = e.pageOffset, e.cacheKey !== void 0 && (t.cache_key = e.cacheKey), e.backgroundColor !== void 0 && (t.background_color = e.backgroundColor), e.pixelPerPt !== void 0 && (t.pixel_per_pt = e.pixelPerPt), e.dataSelection !== void 0) {
      let r = 0;
      e.dataSelection.body ? r |= 1 : e.canvas && tt && (tt = !1, console.warn("dataSelection.body is not set but providing canvas for body")), (e.dataSelection.text || e.dataSelection.annotation) && console.error("dataSelection.text and dataSelection.annotation are deprecated"), e.dataSelection.semantics && (r |= 8), t.data_selection = r;
    }
    return t;
  }
  retrievePagesInfoFromSession(e) {
    return e.retrievePagesInfo();
  }
  /**
   * Render a Typst document to canvas.
   */
  renderCanvas(e) {
    return this.withinOptionSession(e, async (t) => this.renderer.render_page_to_canvas(
      t[E],
      e.canvas || void 0,
      this.canvasOptionsToRust(e)
    ));
  }
  // async renderPdf(artifactContent: string): Promise<Uint8Array> {
  // return this.renderer.render_to_pdf(artifactContent);
  // }
  async inAnimationFrame(e) {
    return new Promise((t, r) => {
      requestAnimationFrame(() => {
        try {
          t(e());
        } catch (i) {
          r(i);
        }
      });
    });
  }
  async renderDisplayLayer(e, t, r) {
    const s = e[E].pages_info.page_count, o = async (f, w) => {
      const C = t[f].getContext("2d");
      if (!C)
        throw new Error("canvas context is null");
      return await this.renderCanvas({
        ...r,
        canvas: C,
        renderSession: e,
        pageOffset: w
      });
    }, a = performance.now(), u = await (async () => {
      const f = [];
      for (let w = 0; w < s; w++)
        f.push(await this.inAnimationFrame(() => o(w, w)));
      return f;
    })(), d = performance.now();
    return console.log(`display layer used: render = ${(d - a).toFixed(1)}ms`), u;
  }
  renderTextLayer(e, t) {
    const r = performance.now();
    e.forEach((s, o) => {
      s.innerHTML = t[o].htmlSemantics[0];
    });
    const i = performance.now();
    console.log(`text layer used: render = ${(i - r).toFixed(1)}ms`);
  }
  async render(e) {
    if ("format" in e && e.format !== "vector" && ["serde_json", "js", "ir"].includes(e.format))
      throw new Error(`deprecated format ${e.format}, please use vector format`);
    return this.renderToCanvas(e);
  }
  async renderDom(e) {
    if ("format" in e && e.format !== "vector" && ["serde_json", "js", "ir"].includes(e.format))
      throw new Error(`deprecated format ${e.format}, please use vector format`);
    return this.withinOptionSession(e, async (t) => {
      const r = new Lr({
        ...e,
        renderMode: "dom",
        hookedElem: e.container,
        kModule: t,
        renderer: this
      });
      return await r.impl.mountDom(e.pixelPerPt), r;
    });
  }
  async renderToCanvas(e) {
    let t, r;
    const i = e.container;
    i.style.visibility = "hidden";
    const s = async (o, a) => {
      try {
        r = await this.renderDisplayLayer(t, o, e), a();
      } finally {
        i.style.visibility = "visible";
      }
    };
    return this.withinOptionSession(e, async (o) => {
      if (t = o, t[E].pages_info.page_count === 0)
        throw new Error("No page found in session");
      if (e.pixelPerPt !== void 0 && e.pixelPerPt <= 0)
        throw new Error(
          "Invalid typst.RenderOptions.pixelPerPt, should be a positive number " + e.pixelPerPt
        );
      let a = e.backgroundColor;
      if (a !== void 0 && !/^#[0-9a-f]{6}$/.test(a))
        throw new Error(
          "Invalid typst.backgroundColor color for matching ^#?[0-9a-f]{6}$ " + a
        );
      t.pixelPerPt = e.pixelPerPt ?? Ve.PIXEL_PER_PT, t.backgroundColor = a ?? "#ffffff";
      const u = performance.now(), d = new It(
        this.retrievePagesInfoFromSession(t),
        i,
        e
      ), f = performance.now();
      console.log(`layer used: retrieve = ${(f - u).toFixed(1)}ms`), await s(d.canvasList, () => d.resetLayout()), this.renderTextLayer(d.textLayerList, r);
    });
  }
  createModule(e) {
    return Promise.resolve(
      new Me(
        this,
        this.renderer.create_session(
          e && this.createOptionsToRust({
            format: "vector",
            artifactContent: e
          })
        )
      )
    );
  }
  async createWorkerV0(e) {
    return new Ar(this, await this.renderer.create_worker(e));
  }
  workerBridge() {
    return this.renderer.create_worker_bridge();
  }
  renderSvg(e, t) {
    if (e instanceof Me || t)
      throw new Error("removed api, please use renderToSvg({ renderSession, container }) instead");
    return this.withinOptionSession(e, async (r) => {
      let i;
      return e.data_selection && (i = 0, e.data_selection.body && (i |= 1), e.data_selection.defs && (i |= 2), e.data_selection.css && (i |= 4), e.data_selection.js && (i |= 8)), Promise.resolve(this.renderer.svg_data(r[E], i));
    });
  }
  renderSvgDiff(e) {
    return e.window ? this.renderer.render_svg_diff(
      e.renderSession[E],
      e.window.lo.x,
      e.window.lo.y,
      e.window.hi.x,
      e.window.hi.y
    ) : this.renderer.render_svg_diff(
      e.renderSession[E],
      0,
      0,
      1e33,
      1e33
    );
  }
  renderToSvg(e) {
    return this.withinOptionSession(e, async (t) => Promise.resolve(this.renderer.render_svg(t[E], e.container)));
  }
  getCustomV1(e) {
    return Promise.resolve(this.renderer.get_customs(e.renderSession[E]));
  }
  resetSession(e) {
    return this.renderer.reset(e[E]);
  }
  manipulateData(e) {
    return this.renderer.manipulate_data(
      e.renderSession[E],
      e.action ?? "reset",
      e.data
    );
  }
  withinOptionSession(e, t) {
    function r(i) {
      return "artifactContent" in i;
    }
    if ("renderSession" in e)
      return t(e.renderSession);
    if (r(e))
      return this.runWithSession(e, t);
    throw new Error(
      "Invalid render options, should be one of RenderByContentOptions|RenderBySessionOptions"
    );
  }
  async runWithSession(e, t) {
    let r = e, i = t;
    t || (r = void 0, i = e);
    const s = this.renderer.create_session(
      /* moved */
      r && this.createOptionsToRust(r)
    );
    try {
      const o = await i(new Me(this, s));
      return s.free(), o;
    } catch (o) {
      throw s.free(), o;
    }
  }
};
var kt;
let Or = (kt = E, class {
  /**
   * @internal
   */
  constructor(e) {
    /**
     * @internal
     */
    l(this, kt);
    this[E] = e;
  }
  /**
   * Reset the incremental server to the initial state.
   */
  reset() {
    this[E].reset();
  }
  /**
   * Return current result.
   */
  current() {
    return this[E].current();
  }
  /**
   * Also attach the debug info to the result.
   */
  setAttachDebugInfo(e) {
    this[E].set_attach_debug_info(e);
  }
});
const Fr = new Mt(async (n) => await (await Promise.resolve().then(() => Re)).default(n));
function Dr() {
  return new $r();
}
let $r = class {
  constructor() {
    l(this, "compiler");
    l(this, "compilerJs");
  }
  async init(e) {
    var a, u, d, f;
    this.compilerJs = await Promise.resolve().then(() => Re);
    const t = this.compilerJs.TypstCompilerBuilder, r = { ...e || {} }, i = (a = r.beforeBuild) == null ? void 0 : a.some(
      (w) => w._preloadRemoteFontOptions !== void 0
    ), s = (u = r.beforeBuild) == null ? void 0 : u.some(
      (w) => {
        var x;
        return ((x = w._preloadRemoteFontOptions) == null ? void 0 : x.assets) !== void 0;
      }
    ), o = (d = r.beforeBuild) == null ? void 0 : d.some(
      (w) => {
        var x;
        return ((x = w._preloadRemoteFontOptions) == null ? void 0 : x.assets) === !1;
      }
    );
    (!i || !s && !o) && ((f = r.beforeBuild) == null || f.push(
      $e([], {
        assets: ["text"]
      })
    )), this.compiler = await Tt(e, Fr, t, {});
  }
  compile(e) {
    return new Promise((t) => {
      if ("incrementalServer" in e) {
        t(
          this.compiler.incr_compile(
            e.mainFilePath,
            Le(e.inputs),
            e.incrementalServer[E],
            rt(e.diagnostics)
          )
        );
        return;
      }
      t(
        this.compiler.compile(
          e.mainFilePath,
          Le(e.inputs),
          e.format || "vector",
          rt(e.diagnostics)
        )
      );
    });
  }
  query(e) {
    return new Promise((t) => {
      t(
        JSON.parse(
          this.compiler.query(
            e.mainFilePath,
            Le(e.inputs),
            e.selector,
            e.field
          )
        )
      );
    });
  }
  getSemanticTokenLegend() {
    return new Promise((e) => {
      e(this.compiler.get_semantic_token_legend());
    });
  }
  getSemanticTokens(e) {
    return new Promise((t) => {
      this.compiler.reset(), t(
        this.compiler.get_semantic_tokens(
          e.offsetEncoding || "utf-16",
          e.mainFilePath,
          e.resultId
        )
      );
    });
  }
  async withIncrementalServer(e) {
    const t = new Or(this.compiler.create_incr_server());
    try {
      return await e(t);
    } finally {
      t[E].free();
    }
  }
  async getAst(e) {
    return this.compiler.get_ast(e);
  }
  async reset() {
    await new Promise((e) => {
      this.compiler.reset(), e(void 0);
    });
  }
  addSource(e, t) {
    if (arguments.length > 2)
      throw new Error(
        "use of addSource(path, source, isMain) is deprecated, please use addSource(path, source) instead"
      );
    this.compiler.add_source(e, t);
  }
  mapShadow(e, t) {
    this.compiler.map_shadow(e, t);
  }
  unmapShadow(e) {
    this.compiler.unmap_shadow(e);
  }
  resetShadow() {
    this.compiler.reset_shadow();
  }
  renderPageToCanvas() {
    throw new Error("Please use the api TypstRenderer.renderToCanvas in v0.4.0");
  }
};
function Le(n) {
  return n ? Object.entries(n) : void 0;
}
function rt(n) {
  switch (n) {
    case "none":
      return 1;
    case "unix":
      return 2;
    case "full":
      return 3;
    default:
      return 0;
  }
}
typeof window < "u" && (window.TypstRenderModule = {
  RenderView: It,
  createTypstRenderer: et,
  createTypstSvgRenderer: et,
  preloadRemoteFonts: $e,
  preloadSystemFonts: Qe
}, window.TypstCompileModule = {
  createTypstCompiler: Dr,
  preloadRemoteFonts: $e,
  preloadSystemFonts: Qe,
  FetchAccessModel: ur,
  MemoryAccessModel: Be,
  FetchPackageRegistry: We,
  withAccessModel: je,
  withPackageRegistry: le
});
window.$typst = ge;
window.TypstSnippet = U;
let nt, Ae;
function jr(n, e) {
  const t = nt || n();
  return Ae !== void 0 ? Ae : Ae = (async () => (await t.init(e), nt = t))();
}
const Br = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createGlobalCompiler: jr
}, Symbol.toStringTag, { value: "Module" }));
class Wr {
  constructor() {
    l(this, "loadedFonts", /* @__PURE__ */ new Set());
    l(this, "fetcher", fetch);
  }
  setFetcher(e) {
    this.fetcher = e;
  }
  async loadFonts(e, t) {
    const r = new Function("m", "return import(m)"), i = this.fetcher || (this.fetcher = await async function() {
      const { fetchBuilder: a, FileSystemCache: u } = await r("node-fetch-cache"), d = new u({
        /// By default, we don't have a complicated cache policy.
        cacheDirectory: ".cache/typst/fonts"
      }), f = a.withCache(d);
      return function(w, x) {
        const C = setTimeout(() => {
          console.warn("font fetching is stucking:", w);
        }, 15e3);
        return f(w, x).finally(() => {
          clearTimeout(C);
        });
      };
    }()), s = t.filter((a) => a instanceof Uint8Array ? !0 : this.loadedFonts.has(a) ? !1 : (this.loadedFonts.add(a), !0)), o = await Promise.all(s.map(async (a) => {
      if (a instanceof Uint8Array) {
        await e.add_raw_font(a);
        return;
      }
      return new Uint8Array(await (await i(a)).arrayBuffer());
    }));
    for (const a of o)
      a && await e.add_raw_font(a);
  }
  async build(e, t, r) {
    const i = { ref: this, builder: t, hooks: r };
    for (const o of (e == null ? void 0 : e.beforeBuild) ?? [])
      await o(void 0, i);
    return r.latelyBuild && r.latelyBuild(i), await t.build();
  }
}
async function Dt(n, e, t, r) {
  var i;
  return await e.init((i = n == null ? void 0 : n.getModule) == null ? void 0 : i.call(n)), await new Wr().build(n, new t(), r);
}
const P = Symbol.for("reflexo-obj");
var pe;
(function(n) {
  n[n.PIXEL_PER_PT = 3] = "PIXEL_PER_PT";
})(pe || (pe = {}));
const zr = [
  "LinLibertine_R.ttf",
  "LinLibertine_RB.ttf",
  "LinLibertine_RBI.ttf",
  "LinLibertine_RI.ttf",
  "NewCMMath-Book.otf",
  "NewCMMath-Regular.otf",
  "NewCM10-Regular.otf",
  "NewCM10-Bold.otf",
  "NewCM10-Italic.otf",
  "NewCM10-BoldItalic.otf",
  "DejaVuSansMono.ttf",
  "DejaVuSansMono-Bold.ttf",
  "DejaVuSansMono-Oblique.ttf",
  "DejaVuSansMono-BoldOblique.ttf"
], qr = [
  "InriaSerif-Bold.ttf",
  "InriaSerif-BoldItalic.ttf",
  "InriaSerif-Italic.ttf",
  "InriaSerif-Regular.ttf",
  "Roboto-Regular.ttf",
  "NotoSerifCJKsc-Regular.otf"
], Nr = ["TwitterColorEmoji.ttf", "NotoColorEmoji.ttf"];
function Ur(n, e) {
  var i, s;
  const t = [...n];
  if (e && (e == null ? void 0 : e.assets) !== !1 && ((i = e == null ? void 0 : e.assets) != null && i.length) && ((s = e == null ? void 0 : e.assets) == null ? void 0 : s.length) > 0) {
    let o = e.assetUrlPrefix ?? "https://raw.githubusercontent.com/Myriad-Dreamin/typst/assets-fonts";
    o[o.length - 1] !== "/" && (o += "/");
    const a = (u) => u.map((d) => o + d);
    for (const u of e.assets)
      switch (u) {
        case "text":
          t.push(...a(zr));
          break;
        case "cjk":
          t.push(...a(qr));
          break;
        case "emoji":
          t.push(...a(Nr));
          break;
      }
  }
  const r = async (o, { ref: a, builder: u }) => {
    e != null && e.fetcher && a.setFetcher(e.fetcher), await a.loadFonts(u, t);
  };
  return r._preloadRemoteFontOptions = e, r;
}
const Hr = (n) => {
  let e = !1, t;
  return () => e ? t : (e = !0, t = n());
};
class $t {
  constructor(e) {
    l(this, "wasmBin");
    l(this, "initOnce");
    if (typeof e != "function")
      throw new Error("initFn is not a function");
    this.initOnce = Hr(async () => {
      await e(this.wasmBin);
    });
  }
  async init(e) {
    this.wasmBin = e, await this.initOnce();
  }
}
var Rt;
Rt = P;
class jt {
  /**
   * @internal
   */
  constructor(e) {
    /**
     * @internal
     */
    l(this, Rt);
    this[P] = e;
  }
  /**
   * Reset the incremental server to the initial state.
   */
  reset() {
    this[P].reset();
  }
  /**
   * Return current result.
   */
  current() {
    return this[P].current();
  }
  /**
   * Also attach the debug info to the result.
   */
  setAttachDebugInfo(e) {
    this[P].set_attach_debug_info(e);
  }
}
const Vr = new $t(async (n) => await (await Promise.resolve().then(() => Re)).default(n));
function Jr() {
  return new Kr();
}
class Kr {
  constructor() {
    l(this, "compiler");
    l(this, "compilerJs");
  }
  async init(e) {
    var a, u, d, f;
    this.compilerJs = await Promise.resolve().then(() => Re);
    const t = this.compilerJs.TypstCompilerBuilder, r = { ...e || {} }, i = (a = r.beforeBuild) == null ? void 0 : a.some((w) => w._preloadRemoteFontOptions !== void 0), s = (u = r.beforeBuild) == null ? void 0 : u.some((w) => {
      var x;
      return ((x = w._preloadRemoteFontOptions) == null ? void 0 : x.assets) !== void 0;
    }), o = (d = r.beforeBuild) == null ? void 0 : d.some((w) => {
      var x;
      return ((x = w._preloadRemoteFontOptions) == null ? void 0 : x.assets) === !1;
    });
    (!i || !s && !o) && ((f = r.beforeBuild) == null || f.push(Ur([], {
      assets: ["text"]
    }))), this.compiler = await Dt(e, Vr, t, {});
  }
  compile(e) {
    return new Promise((t) => {
      if ("incrementalServer" in e) {
        t(this.compiler.incr_compile(e.mainFilePath, Te(e.inputs), e.incrementalServer[P], it(e.diagnostics)));
        return;
      }
      t(this.compiler.compile(e.mainFilePath, Te(e.inputs), e.format || "vector", it(e.diagnostics)));
    });
  }
  query(e) {
    return new Promise((t) => {
      t(JSON.parse(this.compiler.query(e.mainFilePath, Te(e.inputs), e.selector, e.field)));
    });
  }
  getSemanticTokenLegend() {
    return new Promise((e) => {
      e(this.compiler.get_semantic_token_legend());
    });
  }
  getSemanticTokens(e) {
    return new Promise((t) => {
      this.compiler.reset(), t(this.compiler.get_semantic_tokens(e.offsetEncoding || "utf-16", e.mainFilePath, e.resultId));
    });
  }
  async withIncrementalServer(e) {
    const t = new jt(this.compiler.create_incr_server());
    try {
      return await e(t);
    } finally {
      t[P].free();
    }
  }
  async getAst(e) {
    return this.compiler.get_ast(e);
  }
  async reset() {
    await new Promise((e) => {
      this.compiler.reset(), e(void 0);
    });
  }
  addSource(e, t) {
    if (arguments.length > 2)
      throw new Error("use of addSource(path, source, isMain) is deprecated, please use addSource(path, source) instead");
    this.compiler.add_source(e, t);
  }
  mapShadow(e, t) {
    this.compiler.map_shadow(e, t);
  }
  unmapShadow(e) {
    this.compiler.unmap_shadow(e);
  }
  resetShadow() {
    this.compiler.reset_shadow();
  }
  renderPageToCanvas() {
    throw new Error("Please use the api TypstRenderer.renderToCanvas in v0.4.0");
  }
}
function Te(n) {
  return n ? Object.entries(n) : void 0;
}
function it(n) {
  switch (n) {
    case "none":
      return 1;
    case "unix":
      return 2;
    case "full":
      return 3;
    default:
      return 0;
  }
}
const Gr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IncrementalServer: jt,
  createTypstCompiler: Jr
}, Symbol.toStringTag, { value: "Module" }));
let st, Oe;
function Qr(n, e) {
  const t = st || n();
  return Oe !== void 0 ? Oe : Oe = (async () => (await t.init(e), st = t))();
}
const Xr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createGlobalRenderer: Qr
}, Symbol.toStringTag, { value: "Module" }));
class Yr {
  constructor(e, t, r) {
    l(this, "pageInfos");
    l(this, "loadPageCount");
    l(this, "imageScaleFactor");
    l(this, "container");
    l(this, "canvasList");
    l(this, "textLayerList");
    l(this, "commonList");
    l(this, "textLayerParentList");
    l(this, "semanticLayerList");
    this.pageInfos = e, this.imageScaleFactor = r.pixelPerPt ?? pe.PIXEL_PER_PT, t.innerHTML = "", t.style.width = "100%", this.container = t, this.canvasList = new Array(this.loadPageCount), this.textLayerList = new Array(this.loadPageCount), this.commonList = new Array(this.loadPageCount), this.textLayerParentList = new Array(this.loadPageCount), this.semanticLayerList = new Array(this.loadPageCount);
    const i = (s, o, a) => {
      const u = Math.ceil(o.width) * this.imageScaleFactor, d = Math.ceil(o.height) * this.imageScaleFactor, f = this.canvasList[s] = document.createElement("canvas"), w = this.semanticLayerList[s] = document.createElement("div"), x = this.textLayerList[s] = document.createElement("div"), C = this.textLayerParentList[s] = document.createElement("div");
      if (f.getContext("2d")) {
        const A = document.createElement("div");
        f.width = u, f.height = d, A.appendChild(f), a.appendChild(A), A.style.position = "absolute";
      }
      {
        C.appendChild(x), C.className = "typst-html-semantics";
        const A = t.offsetWidth, $ = A / o.width;
        C.style.width = `${A}px`, C.style.height = `${o.height * $}px`, C.style.setProperty("--data-text-width", `${$}px`), C.style.setProperty("--data-text-height", `${$}px`), a.classList.add("typst-page"), a.classList.add("canvas"), a.style.width = `${A}px`, a.style.height = `${d * $}px`, a.style.position = "relative", w.appendChild(C), a.appendChild(w);
      }
    };
    for (let s = 0; s < this.pageInfos.length; s++) {
      const o = this.pageInfos[s];
      let a;
      a = this.commonList[s] = document.createElement("div"), t.appendChild(a), i(s, o, a);
    }
  }
  resetLayout() {
    for (let e = 0; e < this.pageInfos.length; e++) {
      const t = this.pageInfos[e], r = Math.ceil(t.width) * this.imageScaleFactor, i = Math.ceil(t.height) * this.imageScaleFactor, s = this.canvasList[e].parentElement;
      if (!s)
        throw new Error(`canvasDiv is null for page ${e}, canvas list length ${this.canvasList.length}`);
      const o = this.commonList[e], a = this.textLayerParentList[e], u = this.container.offsetWidth, d = u / r;
      a.style.width = `${u}px`, a.style.height = `${i * d}px`, o.style.width = `${u}px`, o.style.height = `${i * d}px`;
      const f = this.container.offsetWidth / r;
      s.style.transformOrigin = "0px 0px", s.style.transform = `scale(${f})`;
    }
  }
}
var G;
(function(n) {
  n[n.Doc = 0] = "Doc", n[n.Slide = 1] = "Slide";
})(G || (G = {}));
class Ke {
  constructor(e) {
    l(this, "hookedElem");
    l(this, "kModule");
    l(this, "opts");
    l(this, "modes", []);
    /// Configuration fields
    /// enable partial rendering
    l(this, "partialRendering", !0);
    /// underlying renderer
    l(this, "renderMode", "svg");
    l(this, "r");
    /// preview mode
    l(this, "previewMode", G.Doc);
    /// whether this is a content preview
    l(this, "isContentPreview", !1);
    /// whether this content preview will mix outline titles
    l(this, "isMixinOutline", !1);
    /// background color
    l(this, "backgroundColor", "black");
    /// default page color (empty string means transparent)
    l(this, "pageColor", "white");
    /// pixel per pt
    l(this, "pixelPerPt", 3);
    /// customized way to retrieving dom state
    l(this, "retrieveDOMState");
    /// State fields
    /// whether svg is updating (in triggerSvgUpdate)
    l(this, "isRendering", !1);
    /// whether kModule is initialized
    l(this, "moduleInitialized", !1);
    /// patch queue for updating data.
    l(this, "patchQueue", []);
    /// resources to dispose
    l(this, "disposeList", []);
    /// canvas render ctoken
    l(this, "canvasRenderCToken");
    /// There are two scales in this class: The real scale is to adjust the size
    /// of `hookedElem` to fit the svg. The virtual scale (scale ratio) is to let
    /// user zoom in/out the svg. For example:
    /// + the default value of virtual scale is 1, which means the svg is totally
    ///   fit in `hookedElem`.
    /// + if user set virtual scale to 0.5, then the svg will be zoomed out to fit
    ///   in half width of `hookedElem`. "real" current scale of `hookedElem`
    l(this, "currentRealScale", 1);
    /// "virtual" current scale of `hookedElem`
    l(this, "currentScaleRatio", 1);
    /// timeout for delayed viewport change
    l(this, "vpTimeout");
    /// sampled by last render time.
    l(this, "sampledRenderTime", 0);
    /// page to partial render
    l(this, "partialRenderPage", 0);
    /// outline data
    l(this, "outline");
    /// cursor position in form of [page, x, y]
    l(this, "cursorPosition");
    // id: number = rnd++;
    /// Cache fields
    /// cached state of container, default to retrieve state from `this.hookedElem`
    l(this, "cachedDOMState", {
      width: 0,
      height: 0,
      window: {
        innerWidth: 0,
        innerHeight: 0
      },
      boundingRect: {
        left: 0,
        top: 0,
        right: 0
      }
    });
    var t, r;
    this.hookedElem = e.hookedElem, this.kModule = e.kModule, this.opts = e || {};
    {
      const { renderMode: i, previewMode: s, isContentPreview: o, retrieveDOMState: a } = e || {};
      this.partialRendering = !1, this.renderMode = i ?? this.renderMode, this.previewMode = s ?? this.previewMode, this.isContentPreview = o || !1, this.retrieveDOMState = a ?? (() => ({
        width: this.hookedElem.offsetWidth,
        height: this.hookedElem.offsetHeight,
        window: {
          innerWidth: window.innerWidth,
          innerHeight: window.innerHeight
        },
        boundingRect: this.hookedElem.getBoundingClientRect()
      })), this.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue("--typst-preview-background-color");
    }
    this.hookedElem.classList.add("hide-scrollbar-x"), (t = this.hookedElem.parentElement) == null || t.classList.add("hide-scrollbar-x"), this.previewMode === G.Slide && (this.hookedElem.classList.add("hide-scrollbar-y"), (r = this.hookedElem.parentElement) == null || r.classList.add("hide-scrollbar-y")), this.installCtrlWheelHandler();
  }
  reset() {
    this.kModule.reset(), this.moduleInitialized = !1;
  }
  dispose() {
    const e = this.disposeList;
    this.disposeList = [], e.forEach((t) => t());
  }
  static derive(e, t) {
    return ["rescale", "rerender", "postRender"].reduce((r, i) => (r[i] = e[`${i}$${t}`].bind(e), console.assert(r[i] !== void 0, `${i}$${t} is undefined`), r), {});
  }
  registerMode(e) {
    const t = Ke.derive(this, e);
    this.modes.push([e, t]), e === this.renderMode && (this.r = t);
  }
  installCtrlWheelHandler() {
    const e = [
      0.1,
      0.2,
      0.3,
      0.4,
      0.5,
      0.6,
      0.7,
      0.8,
      0.9,
      1,
      1.1,
      1.3,
      1.5,
      1.7,
      1.9,
      2.1,
      2.4,
      2.7,
      3,
      3.3,
      3.7,
      4.1,
      4.6,
      5.1,
      5.7,
      6.3,
      7,
      7.7,
      8.5,
      9.4,
      10
    ], t = (r) => {
      var i, s, o, a;
      if (r.ctrlKey) {
        r.preventDefault(), this.cachedDOMState = this.retrieveDOMState(), window.onresize !== null && (window.onresize = null);
        const u = this.currentScaleRatio;
        if (r.deltaY < 0) {
          if (this.currentScaleRatio >= e.at(-1))
            return;
          this.currentScaleRatio = e.filter((C) => C > this.currentScaleRatio).at(0);
        } else if (r.deltaY > 0) {
          if (this.currentScaleRatio <= e.at(0))
            return;
          this.currentScaleRatio = e.filter((C) => C < this.currentScaleRatio).at(-1);
        } else
          return;
        const d = this.currentScaleRatio / u, f = r.pageX * (d - 1), w = r.pageY * (d - 1);
        Math.abs(this.currentScaleRatio - 1) < 1e-5 ? (this.hookedElem.classList.add("hide-scrollbar-x"), (i = this.hookedElem.parentElement) == null || i.classList.add("hide-scrollbar-x"), this.previewMode === G.Slide && (this.hookedElem.classList.add("hide-scrollbar-y"), (s = this.hookedElem.parentElement) == null || s.classList.add("hide-scrollbar-y"))) : (this.hookedElem.classList.remove("hide-scrollbar-x"), (o = this.hookedElem.parentElement) == null || o.classList.remove("hide-scrollbar-x"), this.previewMode === G.Slide && (this.hookedElem.classList.remove("hide-scrollbar-y"), (a = this.hookedElem.parentElement) == null || a.classList.remove("hide-scrollbar-y")));
        const x = this.hookedElem.firstElementChild;
        if (x) {
          const C = this.getSvgScaleRatio(), F = Number.parseFloat(x.getAttribute("data-height")), A = Math.ceil(F * C);
          this.hookedElem.style.height = `${A * 2}px`;
        }
        return window.scrollBy(f, w), this.addViewportChange(), !1;
      }
    };
    this.renderMode !== "dom" && (typeof acquireVsCodeApi < "u" ? (window.addEventListener("wheel", t, {
      passive: !1
    }), this.disposeList.push(() => {
      window.removeEventListener("wheel", t);
    })) : (document.body.addEventListener("wheel", t, {
      passive: !1
    }), this.disposeList.push(() => {
      document.body.removeEventListener("wheel", t);
    })));
  }
  /// Get current scale from html to svg
  // Note: one should retrieve dom state before rescale
  getSvgScaleRatio() {
    const e = this.hookedElem.firstElementChild;
    if (!e)
      return 0;
    const t = this.cachedDOMState, r = Number.parseFloat(e.getAttribute("data-width") || e.getAttribute("width") || "1"), i = Number.parseFloat(e.getAttribute("data-height") || e.getAttribute("height") || "1");
    return this.currentRealScale = this.previewMode === G.Slide ? Math.min(t.width / r, t.height / i) : t.width / r, this.currentRealScale * this.currentScaleRatio;
  }
  processQueue(e) {
    const t = e[0];
    switch (t) {
      case "new":
      case "diff-v1":
        return t === "new" && this.reset(), this.kModule.manipulateData({
          action: "merge",
          data: e[1]
        }), this.moduleInitialized = !0, !0;
      case "viewport-change":
        return this.moduleInitialized ? !0 : (console.log("viewport-change before initialization"), !1);
      default:
        return console.log("svgUpdateEvent", e), !1;
    }
  }
  triggerUpdate() {
    if (this.isRendering)
      return;
    this.isRendering = !0;
    const e = async () => {
      if (this.cachedDOMState = this.retrieveDOMState(), this.patchQueue.length === 0) {
        this.isRendering = !1, this.postprocessChanges();
        return;
      }
      try {
        let t = performance.now();
        const r = this.canvasRenderCToken;
        r && (await r.cancel(), await r.wait(), this.canvasRenderCToken = void 0, console.log("cancel canvas rendering"));
        let i = !1;
        for (; this.patchQueue.length > 0; )
          i = this.processQueue(this.patchQueue.shift()) || i;
        let s = performance.now();
        i && (this.r.rescale(), await this.r.rerender(), this.r.rescale());
        let o = performance.now();
        const a = (u, d, f) => `${u} ${(f - d).toFixed(2)} ms`;
        this.sampledRenderTime = o - t, console.log([a("parse", t, s), a("rerender", s, o), a("total", t, o)].join(", ")), requestAnimationFrame(e);
      } catch (t) {
        console.error(t), this.isRendering = !1, this.postprocessChanges();
      }
    };
    requestAnimationFrame(e);
  }
  postprocessChanges() {
    this.r.postRender(), this.previewMode === G.Slide && document.querySelectorAll(".typst-page-number-indicator").forEach((e) => {
      e.textContent = `${this.kModule.retrievePagesInfo().length}`;
    });
  }
  addChangement(e) {
    e[0] === "new" && this.patchQueue.splice(0, this.patchQueue.length);
    const t = () => {
      this.vpTimeout = void 0, this.patchQueue.push(e), this.triggerUpdate();
    };
    this.vpTimeout !== void 0 && clearTimeout(this.vpTimeout), e[0] === "viewport-change" && this.isRendering ? this.vpTimeout = setTimeout(t, this.sampledRenderTime || 100) : t();
  }
  addViewportChange() {
    this.addChangement(["viewport-change", ""]);
  }
}
function Zr(n) {
  return class {
    constructor(t) {
      l(this, "impl");
      l(this, "kModule");
      if (t.isContentPreview && (t.renderMode = "canvas"), this.kModule = t.kModule, this.impl = new n(t), !this.impl.r)
        throw new Error(`mode is not supported, ${t == null ? void 0 : t.renderMode}`);
      t.isContentPreview && (this.impl.partialRendering = !0, this.impl.pixelPerPt = 1, this.impl.isMixinOutline = !0);
    }
    dispose() {
      this.impl.dispose();
    }
    reset() {
      this.impl.reset();
    }
    addChangement(t) {
      this.impl.addChangement(t);
    }
    addViewportChange() {
      this.impl.addViewportChange();
    }
    setPageColor(t) {
      this.impl.pageColor = t, this.addViewportChange();
    }
    setPartialRendering(t) {
      this.impl.partialRendering = t;
    }
    setCursor(t, r, i) {
      this.impl.cursorPosition = [t, r, i];
    }
    setPartialPageNumber(t) {
      return t <= 0 || t > this.kModule.retrievePagesInfo().length ? !1 : (this.impl.partialRenderPage = t - 1, this.addViewportChange(), !0);
    }
    getPartialPageNumber() {
      return this.impl.partialRenderPage + 1;
    }
    setOutineData(t) {
      this.impl.outline = t, this.addViewportChange();
    }
  };
}
function en(n, ...e) {
  return e.reduce((t, r) => r(t), n);
}
class tn {
  constructor() {
    l(this, "isCancellationRequested", !1);
    l(this, "_onCancelled");
    l(this, "_onCancelledResolveResolved");
    let e, t;
    this._onCancelled = new Promise((r) => {
      e = r, t && t(r);
    }), this._onCancelledResolveResolved = new Promise((r) => {
      t = r, e && r(e);
    });
  }
  async cancel() {
    await this._onCancelledResolveResolved, this.isCancellationRequested = !0;
  }
  isCancelRequested() {
    return this.isCancellationRequested;
  }
  async consume() {
    (await this._onCancelledResolveResolved)();
  }
  wait() {
    return this._onCancelled;
  }
}
const rn = () => new Promise((n) => requestAnimationFrame(n));
var Ne;
(function(n) {
  n[n.Doc = 0] = "Doc", n[n.Pages = 1] = "Pages";
})(Ne || (Ne = {}));
var q;
(function(n) {
  n[n.Layout = 0] = "Layout", n[n.Svg = 1] = "Svg", n[n.Semantics = 2] = "Semantics", n[n.PrepareCanvas = 3] = "PrepareCanvas", n[n.Canvas = 4] = "Canvas";
})(q || (q = {}));
function nn(n) {
  return class extends n {
    constructor(...r) {
      super(...r);
      /// The template element for creating DOM by string.
      l(this, "tmpl", document.createElement("template"));
      /// The stub element for replacing an invisible element.
      l(this, "stub", this.createElement("<stub></stub>"));
      /// Typescript side of lib.
      l(this, "plugin");
      /// Rust side of kernel.
      l(this, "docKernel");
      /// The element to track.
      l(this, "resourceHeader");
      /// Expected exact state of the current DOM.
      /// Initially it is empty meaning no any page is rendered.
      l(this, "pages", []);
      /// The virtual scale of the document.
      l(this, "domScale", 1);
      /// Track mode.
      l(this, "track_mode", Ne.Doc);
      /// Current executing task.
      l(this, "current_task");
      /// The currently maintained viewport.
      l(this, "viewport");
      if (this.registerMode("dom"), this.disposeList.push(() => {
        this.dispose();
      }), this.plugin = this.opts.renderer, this.opts.domScale !== void 0) {
        if (this.opts.domScale <= 0)
          throw new Error("domScale must be positive");
        this.domScale = this.opts.domScale;
      }
    }
    dispose() {
      for (const r of this.pages)
        r.dispose();
      this.docKernel && this.docKernel.free();
    }
    createElement(r) {
      return this.tmpl.innerHTML = r, this.tmpl.content.firstElementChild;
    }
    async mountDom(r) {
      if (console.log("mountDom", r), this.docKernel)
        throw new Error("already mounted");
      this.hookedElem.innerHTML = '<svg class="typst-svg-resources" viewBox="0 0 0 0" width="0" height="0" style="opacity: 0; position: absolute;"></svg>', this.resourceHeader = this.hookedElem.querySelector(".typst-svg-resources"), this.docKernel = await this.plugin.renderer.mount_dom(this.kModule[P], this.hookedElem), this.docKernel.bind_functions({
        populateGlyphs: (i) => {
          let s = this.createElement(i);
          console.log("populateGlyphs", s);
          let o = s.firstElementChild;
          this.resourceHeader.append(o);
        }
      });
    }
    async cancelAnyway$dom() {
      if (console.log("cancelAnyway$dom"), this.current_task) {
        const r = this.current_task;
        this.current_task = void 0, await r.cancel();
      }
    }
    retrieveDOMPages() {
      return Array.from(this.hookedElem.querySelectorAll(".typst-dom-page"));
    }
    // doesn't need to postRender
    postRender$dom() {
    }
    // doesn't need to rescale
    rescale$dom() {
    }
    getDomViewport(r, i) {
      const s = i.left, o = -i.top, a = i.right, u = r.innerHeight - i.top, d = {
        x: 0,
        y: o / this.domScale,
        width: Math.max(a - s, 0) / this.domScale,
        height: Math.max(u - o, 0) / this.domScale
      };
      return (d.width <= 0 || d.height <= 0) && (d.x = d.y = d.width = d.height = 0), d;
    }
    // fast mode
    async rerender$dom() {
      const r = this.retrieveDOMState(), { x: i, y: s, width: o, height: a } = this.getDomViewport(r.window, r.boundingRect);
      if (!await this.docKernel.relayout(i, s, o, a))
        return;
      const d = new tn();
      this.doRender$dom(d), this.current_task = d;
    }
    async doRender$dom(r) {
      const i = (u, d) => {
        if (u && !r.isCancelRequested() && d)
          return d();
      }, s = this.retrieveDOMPages().map((u) => {
        const { innerWidth: d, innerHeight: f } = window, w = u.getBoundingClientRect();
        return {
          inWindow: !(w.left > d || w.right < 0 || w.top > f || w.bottom < 0),
          page: u
        };
      }), o = async (u) => {
        if (await rn(), r.isCancelRequested()) {
          console.log("cancel stage", q.Layout, u);
          return;
        }
        const d = s[u].page, f = d.getBoundingClientRect(), w = this.getDomViewport(window, f), x = (D) => this.docKernel.need_repaint(u, w.x, w.y, w.width, w.height, D), C = (D) => this.docKernel.repaint(u, w.x, w.y, w.width, w.height, D), F = (D) => {
          if (!r.isCancelRequested())
            return i(x(D), () => C(D));
        };
        await F(q.Layout);
        const A = (f.width ? Number.parseFloat(d.getAttribute("data-width")) / f.width : 1) * this.domScale, $ = (f.height ? Number.parseFloat(d.getAttribute("data-height")) / f.height : 1) * this.domScale;
        if (w.x *= A, w.y *= $, w.y -= 100, w.width *= A, w.height *= $, w.height += 200, await F(q.Svg), await F(q.Semantics), r.isCancelRequested()) {
          console.log("cancel stage", q.Semantics, u);
          return;
        }
        x(q.PrepareCanvas) ? (async () => {
          if (await C(q.PrepareCanvas), !r.isCancelRequested())
            return F(q.Canvas);
        })() : await F(q.Canvas);
      }, a = async (u) => {
        for (let d = 0; d < s.length; ++d) {
          if (r.isCancelRequested()) {
            console.log("cancel page", q.Layout, d);
            return;
          }
          s[d].inWindow === u && await o(d);
        }
      };
      this.cancelAnyway$dom(), await a(!0), await a(!1), !r.isCancelRequested() && console.log("finished", q.Layout);
    }
  };
}
class sn extends Zr(en(Ke, nn)) {
}
var Et;
let fe = (Et = P, class {
  /**
   * @internal
   */
  constructor(e, t) {
    l(this, "plugin");
    /**
     * @internal
     */
    l(this, Et);
    this.plugin = e, this[P] = t;
  }
  /**
   * @deprecated set in {@link RenderToCanvasOptions} instead
   *
   * Set the background color of the Typst document.
   * @param {string} t - The background color in format of `^#?[0-9a-f]{6}$`
   *
   * Note: Default to `#ffffff`.
   *
   * Note: Only available in canvas rendering mode.
   */
  set backgroundColor(e) {
    e !== void 0 && (this[P].background_color = e);
  }
  /**
   * Get the background color of the Typst document.
   *
   * Note: Default to `#ffffff`.
   *
   * Note: Only available in canvas rendering mode.
   */
  get backgroundColor() {
    return this[P].background_color;
  }
  /**
   * Set the pixel per point scale up the canvas panel.
   *
   * Note: Default to `3`.
   *
   * Note: Only available in canvas rendering mode.
   */
  set pixelPerPt(e) {
    e !== void 0 && (this[P].pixel_per_pt = e);
  }
  /**
   * @deprecated set in {@link RenderToCanvasOptions} instead
   *
   * Get the pixel per point scale up the canvas panel.
   *
   * Note: Default to `3`.
   *
   * Note: Only available in canvas rendering mode.
   */
  get pixelPerPt() {
    return this[P].pixel_per_pt;
  }
  /**
   * Reset state
   */
  reset() {
    this.plugin.resetSession(this);
  }
  /**
   * @deprecated
   * use {@link docWidth} instead
   */
  get doc_width() {
    return this[P].doc_width;
  }
  get docWidth() {
    return this[P].doc_width;
  }
  /**
   * @deprecated
   * use {@link docHeight} instead
   */
  get doc_height() {
    return this[P].doc_height;
  }
  get docHeight() {
    return this[P].doc_height;
  }
  retrievePagesInfo() {
    const e = this[P].pages_info, t = [], r = e.page_count;
    for (let i = 0; i < r; i++) {
      const s = e.page(i);
      t.push({
        pageOffset: s.page_off,
        width: s.width_pt,
        height: s.height_pt
      });
    }
    return t;
  }
  getSourceLoc(e) {
    return this[P].source_span(e);
  }
  /**
   * See {@link TypstRenderer#renderSvg} for more details.
   */
  renderSvg(e) {
    return this.plugin.renderSvg({
      renderSession: this,
      ...e
    });
  }
  /**
   * See {@link TypstRenderer#renderToSvg} for more details.
   */
  renderToSvg(e) {
    return this.plugin.renderToSvg({
      renderSession: this,
      ...e
    });
  }
  /**
   * See {@link TypstRenderer#renderCanvas} for more details.
   */
  renderCanvas(e) {
    return this.plugin.renderCanvas({
      renderSession: this,
      ...e
    });
  }
  /**
   * See {@link TypstRenderer#manipulateData} for more details.
   */
  manipulateData(e) {
    this.plugin.manipulateData({
      renderSession: this,
      ...e
    });
  }
  /**
   * See {@link TypstRenderer#renderSvgDiff} for more details.
   */
  renderSvgDiff(e) {
    return this.plugin.renderSvgDiff({
      renderSession: this,
      ...e
    });
  }
  /**
   * @deprecated
   * use {@link getSourceLoc} instead
   */
  get_source_loc(e) {
    return this[P].source_span(e);
  }
  /**
   * @deprecated
   * use {@link renderSvgDiff} instead
   */
  render_in_window(e, t, r, i) {
    return this[P].render_in_window(e, t, r, i);
  }
  /**
   * @deprecated
   * use {@link manipulateData} instead
   */
  merge_delta(e) {
    this.plugin.manipulateData({
      renderSession: this,
      action: "merge",
      data: e
    });
  }
});
var Z;
(function(n) {
  n[n.Delete = 0] = "Delete", n[n.New = 1] = "New", n[n.Update = 2] = "Update";
})(Z || (Z = {}));
var Pt;
let Bt = (Pt = P, class {
  /**
   * @internal
   */
  constructor(e, t) {
    l(this, "plugin");
    /**
     * @internal
     */
    l(this, Pt);
    /**
     * @internal
     */
    l(this, "managedCanvasElemList", /* @__PURE__ */ new Map());
    /**
     * @internal
     */
    l(this, "canvasCounter", Math.random());
    this.plugin = e, this[P] = t;
  }
  /**
   * See {@link TypstRenderer#manipulateData} for more details.
   */
  manipulateData(e, t) {
    return this[P].manipulate_data(e, t);
  }
  /**
   * You must submit all canvas in pages to ensure synchronization with the background worker
   *
   * See {@link TypstRenderer#renderCanvas} for more details.
   */
  renderCanvas(e) {
    const t = this.managedCanvasElemList;
    for (const [a, u] of t)
      u[0] = Z.Delete;
    for (const a of e) {
      const u = a.canvas;
      let d = u.dataset.manageId, f = Z.Update;
      d || (d = this.canvasCounter.toFixed(5), this.canvasCounter += 1, u.dataset.manageId = d, f = Z.New);
      let w = t.get(d);
      if (w && w[0] !== Z.Delete)
        throw new Error("cannot update a canvas for two times in batch");
      t.set(d, [f, { ...a }]);
    }
    const r = Array.from(t.entries()), i = new Uint8Array(r.length), s = new Array(r.length), o = r.map(([a, [u, d]], f) => (u || t.delete(a), i[f] = u, s[f] = d.canvas, this.plugin.canvasOptionsToRust(d)));
    return this[P].render_canvas(i, s, o);
  }
  async retrievePagesInfo() {
    const e = await this[P].get_pages_info();
    console.log(e);
    const t = [], r = e.page_count;
    for (let i = 0; i < r; i++) {
      const s = e.page(i);
      t.push({
        pageOffset: s.page_off,
        width: s.width_pt,
        height: s.height_pt
      });
    }
    return t;
  }
});
const on = (n) => new $t(async (e) => await n.default(e));
function an() {
  return new Wt();
}
let ot = !0;
class Wt {
  constructor() {
    l(this, "renderer");
    l(this, "rendererJs");
  }
  async init(e) {
    var r;
    this.rendererJs = await (((r = e == null ? void 0 : e.getWrapper) == null ? void 0 : r.call(e)) || Promise.resolve().then(() => Ge));
    const t = this.rendererJs.TypstRendererBuilder;
    this.renderer = await Dt(e, on(this.rendererJs), t, {});
  }
  loadGlyphPack(e) {
    return Promise.resolve();
  }
  createOptionsToRust(e) {
    const t = new this.rendererJs.CreateSessionOptions();
    return e.format !== void 0 && (t.format = e.format), e.artifactContent !== void 0 && (t.artifact_content = e.artifactContent), t;
  }
  canvasOptionsToRust(e) {
    const t = new this.rendererJs.RenderPageImageOptions();
    if (e.pageOffset === void 0)
      throw new Error("pageOffset is required in reflexo v0.5.0");
    if (t.page_off = e.pageOffset, e.cacheKey !== void 0 && (t.cache_key = e.cacheKey), e.backgroundColor !== void 0 && (t.background_color = e.backgroundColor), e.pixelPerPt !== void 0 && (t.pixel_per_pt = e.pixelPerPt), e.dataSelection !== void 0) {
      let r = 0;
      e.dataSelection.body ? r |= 1 : e.canvas && ot && (ot = !1, console.warn("dataSelection.body is not set but providing canvas for body")), (e.dataSelection.text || e.dataSelection.annotation) && console.error("dataSelection.text and dataSelection.annotation are deprecated"), e.dataSelection.semantics && (r |= 8), t.data_selection = r;
    }
    return t;
  }
  retrievePagesInfoFromSession(e) {
    return e.retrievePagesInfo();
  }
  /**
   * Render a Typst document to canvas.
   */
  renderCanvas(e) {
    return this.withinOptionSession(e, async (t) => this.renderer.render_page_to_canvas(t[P], e.canvas || void 0, this.canvasOptionsToRust(e)));
  }
  // async renderPdf(artifactContent: string): Promise<Uint8Array> {
  // return this.renderer.render_to_pdf(artifactContent);
  // }
  async inAnimationFrame(e) {
    return new Promise((t, r) => {
      requestAnimationFrame(() => {
        try {
          t(e());
        } catch (i) {
          r(i);
        }
      });
    });
  }
  async renderDisplayLayer(e, t, r) {
    const s = e[P].pages_info.page_count, o = async (f, w) => {
      const C = t[f].getContext("2d");
      if (!C)
        throw new Error("canvas context is null");
      return await this.renderCanvas({
        ...r,
        canvas: C,
        renderSession: e,
        pageOffset: w
      });
    }, a = performance.now(), u = await (async () => {
      const f = [];
      for (let w = 0; w < s; w++)
        f.push(await this.inAnimationFrame(() => o(w, w)));
      return f;
    })(), d = performance.now();
    return console.log(`display layer used: render = ${(d - a).toFixed(1)}ms`), u;
  }
  renderTextLayer(e, t) {
    const r = performance.now();
    e.forEach((s, o) => {
      s.innerHTML = t[o].htmlSemantics[0];
    });
    const i = performance.now();
    console.log(`text layer used: render = ${(i - r).toFixed(1)}ms`);
  }
  async render(e) {
    if ("format" in e && e.format !== "vector" && ["serde_json", "js", "ir"].includes(e.format))
      throw new Error(`deprecated format ${e.format}, please use vector format`);
    return this.renderToCanvas(e);
  }
  async renderDom(e) {
    if ("format" in e && e.format !== "vector" && ["serde_json", "js", "ir"].includes(e.format))
      throw new Error(`deprecated format ${e.format}, please use vector format`);
    return this.withinOptionSession(e, async (t) => {
      const r = new sn({
        ...e,
        renderMode: "dom",
        hookedElem: e.container,
        kModule: t,
        renderer: this
      });
      return await r.impl.mountDom(e.pixelPerPt), r;
    });
  }
  async renderToCanvas(e) {
    let t, r;
    const i = e.container;
    i.style.visibility = "hidden";
    const s = async (o, a) => {
      try {
        r = await this.renderDisplayLayer(t, o, e), a();
      } finally {
        i.style.visibility = "visible";
      }
    };
    return this.withinOptionSession(e, async (o) => {
      if (t = o, t[P].pages_info.page_count === 0)
        throw new Error("No page found in session");
      if (e.pixelPerPt !== void 0 && e.pixelPerPt <= 0)
        throw new Error("Invalid typst.RenderOptions.pixelPerPt, should be a positive number " + e.pixelPerPt);
      let a = e.backgroundColor;
      if (a !== void 0 && !/^#[0-9a-f]{6}$/.test(a))
        throw new Error("Invalid typst.backgroundColor color for matching ^#?[0-9a-f]{6}$ " + a);
      t.pixelPerPt = e.pixelPerPt ?? pe.PIXEL_PER_PT, t.backgroundColor = a ?? "#ffffff";
      const u = performance.now(), d = new Yr(this.retrievePagesInfoFromSession(t), i, e), f = performance.now();
      console.log(`layer used: retrieve = ${(f - u).toFixed(1)}ms`), await s(d.canvasList, () => d.resetLayout()), this.renderTextLayer(d.textLayerList, r);
    });
  }
  createModule(e) {
    return Promise.resolve(new fe(this, this.renderer.create_session(e && this.createOptionsToRust({
      format: "vector",
      artifactContent: e
    }))));
  }
  async createWorkerV0(e) {
    return new Bt(this, await this.renderer.create_worker(e));
  }
  workerBridge() {
    return this.renderer.create_worker_bridge();
  }
  renderSvg(e, t) {
    if (e instanceof fe || t)
      throw new Error("removed api, please use renderToSvg({ renderSession, container }) instead");
    return this.withinOptionSession(e, async (r) => {
      let i;
      return e.data_selection && (i = 0, e.data_selection.body && (i |= 1), e.data_selection.defs && (i |= 2), e.data_selection.css && (i |= 4), e.data_selection.js && (i |= 8)), Promise.resolve(this.renderer.svg_data(r[P], i));
    });
  }
  renderSvgDiff(e) {
    return e.window ? this.renderer.render_svg_diff(e.renderSession[P], e.window.lo.x, e.window.lo.y, e.window.hi.x, e.window.hi.y) : this.renderer.render_svg_diff(e.renderSession[P], 0, 0, 1e33, 1e33);
  }
  renderToSvg(e) {
    return this.withinOptionSession(e, async (t) => Promise.resolve(this.renderer.render_svg(t[P], e.container)));
  }
  getCustomV1(e) {
    return Promise.resolve(this.renderer.get_customs(e.renderSession[P]));
  }
  resetSession(e) {
    return this.renderer.reset(e[P]);
  }
  manipulateData(e) {
    return this.renderer.manipulate_data(e.renderSession[P], e.action ?? "reset", e.data);
  }
  withinOptionSession(e, t) {
    function r(i) {
      return "artifactContent" in i;
    }
    if ("renderSession" in e)
      return t(e.renderSession);
    if (r(e))
      return this.runWithSession(e, t);
    throw new Error("Invalid render options, should be one of RenderByContentOptions|RenderBySessionOptions");
  }
  async runWithSession(e, t) {
    let r = e, i = t;
    t || (r = void 0, i = e);
    const s = this.renderer.create_session(
      /* moved */
      r && this.createOptionsToRust(r)
    );
    try {
      const o = await i(new fe(this, s));
      return s.free(), o;
    } catch (o) {
      throw s.free(), o;
    }
  }
}
const cn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RenderSession: fe,
  TypstRendererDriver: Wt,
  TypstWorker: Bt,
  createTypstRenderer: an
}, Symbol.toStringTag, { value: "Module" }));
let c;
const J = new Array(128).fill(void 0);
J.push(void 0, null, !0, !1);
function _(n) {
  return J[n];
}
let ee = J.length;
function y(n) {
  ee === J.length && J.push(J.length + 1);
  const e = ee;
  if (ee = J[e], typeof ee != "number") throw new Error("corrupt heap");
  return J[e] = n, e;
}
function k(n, e) {
  try {
    return n.apply(this, e);
  } catch (t) {
    c.__wbindgen_export_0(y(t));
  }
}
function h(n, e) {
  try {
    return n.apply(this, e);
  } catch (t) {
    let r = function() {
      try {
        return t instanceof Error ? `${t.message}

Stack:
${t.stack}` : t.toString();
      } catch {
        return "<failed to stringify thrown value>";
      }
    }();
    throw console.error("wasm-bindgen: imported JS function that was not marked as `catch` threw an error:", r), t;
  }
}
function p(n) {
  if (typeof n != "number") throw new Error(`expected a number argument, found ${typeof n}`);
}
const zt = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && zt.decode();
let re = null;
function oe() {
  return (re === null || re.byteLength === 0) && (re = new Uint8Array(c.memory.buffer)), re;
}
function R(n, e) {
  return n = n >>> 0, zt.decode(oe().subarray(n, n + e));
}
let O = 0;
const we = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, _n = typeof we.encodeInto == "function" ? function(n, e) {
  return we.encodeInto(n, e);
} : function(n, e) {
  const t = we.encode(n);
  return e.set(t), {
    read: n.length,
    written: t.length
  };
};
function W(n, e, t) {
  if (typeof n != "string") throw new Error(`expected a string argument, found ${typeof n}`);
  if (t === void 0) {
    const a = we.encode(n), u = e(a.length, 1) >>> 0;
    return oe().subarray(u, u + a.length).set(a), O = a.length, u;
  }
  let r = n.length, i = e(r, 1) >>> 0;
  const s = oe();
  let o = 0;
  for (; o < r; o++) {
    const a = n.charCodeAt(o);
    if (a > 127) break;
    s[i + o] = a;
  }
  if (o !== r) {
    o !== 0 && (n = n.slice(o)), i = t(i, r, r = o + n.length * 3, 1) >>> 0;
    const a = oe().subarray(i + o, i + r), u = _n(n, a);
    if (u.read !== n.length) throw new Error("failed to pass whole string");
    o += u.written, i = t(i, r, o, 1) >>> 0;
  }
  return O = o, i;
}
let Q = null;
function m() {
  return (Q === null || Q.buffer.detached === !0 || Q.buffer.detached === void 0 && Q.buffer !== c.memory.buffer) && (Q = new DataView(c.memory.buffer)), Q;
}
function L(n) {
  return n == null;
}
function j(n) {
  if (typeof n != "boolean")
    throw new Error(`expected a boolean argument, found ${typeof n}`);
}
function un(n) {
  n < 132 || (J[n] = ee, ee = n);
}
function M(n) {
  const e = _(n);
  return un(n), e;
}
const be = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => {
  c.__wbindgen_export_4.get(n.dtor)(n.a, n.b);
});
function at(n, e, t, r) {
  const i = { a: n, b: e, cnt: 1, dtor: t }, s = (...o) => {
    i.cnt++;
    try {
      return r(i.a, i.b, ...o);
    } finally {
      --i.cnt === 0 && (c.__wbindgen_export_4.get(i.dtor)(i.a, i.b), i.a = 0, be.unregister(i));
    }
  };
  return s.original = i, be.register(s, i, i), s;
}
function dn(n, e, t, r) {
  const i = { a: n, b: e, cnt: 1, dtor: t }, s = (...o) => {
    i.cnt++;
    const a = i.a;
    i.a = 0;
    try {
      return r(a, i.b, ...o);
    } finally {
      --i.cnt === 0 ? (c.__wbindgen_export_4.get(i.dtor)(a, i.b), be.unregister(i)) : i.a = a;
    }
  };
  return s.original = i, be.register(s, i, i), s;
}
function Ue(n) {
  const e = typeof n;
  if (e == "number" || e == "boolean" || n == null)
    return `${n}`;
  if (e == "string")
    return `"${n}"`;
  if (e == "symbol") {
    const i = n.description;
    return i == null ? "Symbol" : `Symbol(${i})`;
  }
  if (e == "function") {
    const i = n.name;
    return typeof i == "string" && i.length > 0 ? `Function(${i})` : "Function";
  }
  if (Array.isArray(n)) {
    const i = n.length;
    let s = "[";
    i > 0 && (s += Ue(n[0]));
    for (let o = 1; o < i; o++)
      s += ", " + Ue(n[o]);
    return s += "]", s;
  }
  const t = /\[object ([^\]]+)\]/.exec(toString.call(n));
  let r;
  if (t && t.length > 1)
    r = t[1];
  else
    return toString.call(n);
  if (r == "Object")
    try {
      return "Object(" + JSON.stringify(n) + ")";
    } catch {
      return "Object";
    }
  return n instanceof Error ? `${n.name}: ${n.message}
${n.stack}` : r;
}
function me(n, e) {
  const t = e(n.length * 1, 1) >>> 0;
  return oe().set(n, t / 1), O = n.length, t;
}
function ct(n, e) {
  const t = e(n.length * 4, 4) >>> 0, r = m();
  for (let i = 0; i < n.length; i++)
    r.setUint32(t + 4 * i, y(n[i]), !0);
  return O = n.length, t;
}
function H(n, e) {
  if (!(n instanceof e))
    throw new Error(`expected instance of ${e.name}`);
}
function ln() {
  const n = c.renderer_build_info();
  return M(n);
}
let ne = null;
function gn() {
  return (ne === null || ne.byteLength === 0) && (ne = new Uint32Array(c.memory.buffer)), ne;
}
function fn(n, e) {
  const t = e(n.length * 4, 4) >>> 0;
  return gn().set(n, t / 4), O = n.length, t;
}
function wn(n, e) {
  p(n), p(e), c.__wbindgen_export_5(n, e);
}
function hn(n, e, t) {
  p(n), p(e), c.__wbindgen_export_6(n, e, y(t));
}
function pn(n, e, t) {
  p(n), p(e), c.__wbindgen_export_7(n, e, y(t));
}
function bn(n, e, t, r) {
  p(n), p(e), c.__wbindgen_export_8(n, e, y(t), y(r));
}
const _t = ["nonzero", "evenodd"], ut = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => c.__wbg_createsessionoptions_free(n >>> 0, 1));
class qt {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ut.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    c.__wbg_createsessionoptions_free(e, 0);
  }
  constructor() {
    const e = c.createsessionoptions_new();
    return this.__wbg_ptr = e >>> 0, ut.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * @param {string} format
   */
  set format(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const t = W(e, c.__wbindgen_export_1, c.__wbindgen_export_2), r = O;
    c.createsessionoptions_set_format(this.__wbg_ptr, t, r);
  }
  /**
   * @param {Uint8Array} artifact_content
   */
  set artifact_content(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const t = me(e, c.__wbindgen_export_1), r = O;
    c.createsessionoptions_set_artifact_content(this.__wbg_ptr, t, r);
  }
}
const dt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => c.__wbg_incrdomdocclient_free(n >>> 0, 1));
class ye {
  constructor() {
    throw new Error("cannot invoke `new` directly");
  }
  static __wrap(e) {
    e = e >>> 0;
    const t = Object.create(ye.prototype);
    return t.__wbg_ptr = e, dt.register(t, t.__wbg_ptr, t), t;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, dt.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    c.__wbg_incrdomdocclient_free(e, 0);
  }
  /**
   * @param {any} functions
   */
  bind_functions(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr), c.incrdomdocclient_bind_functions(this.__wbg_ptr, y(e));
  }
  /**
   * Relayout the document in the given window.
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @returns {Promise<boolean>}
   */
  relayout(e, t, r, i) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const s = c.incrdomdocclient_relayout(this.__wbg_ptr, e, t, r, i);
    return M(s);
  }
  /**
   * @param {number} page_num
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {number} stage
   * @returns {boolean}
   */
  need_repaint(e, t, r, i, s, o) {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const f = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr), p(e), p(o), c.incrdomdocclient_need_repaint(f, this.__wbg_ptr, e, t, r, i, s, o);
      var a = m().getInt32(f + 4 * 0, !0), u = m().getInt32(f + 4 * 1, !0), d = m().getInt32(f + 4 * 2, !0);
      if (d)
        throw M(u);
      return a !== 0;
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} page_num
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {number} stage
   * @returns {any}
   */
  repaint(e, t, r, i, s, o) {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const f = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr), p(e), p(o), c.incrdomdocclient_repaint(f, this.__wbg_ptr, e, t, r, i, s, o);
      var a = m().getInt32(f + 4 * 0, !0), u = m().getInt32(f + 4 * 1, !0), d = m().getInt32(f + 4 * 2, !0);
      if (d)
        throw M(u);
      return M(a);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
}
const lt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => c.__wbg_pageinfo_free(n >>> 0, 1));
class ce {
  constructor() {
    throw new Error("cannot invoke `new` directly");
  }
  static __wrap(e) {
    e = e >>> 0;
    const t = Object.create(ce.prototype);
    return t.__wbg_ptr = e, lt.register(t, t.__wbg_ptr, t), t;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, lt.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    c.__wbg_pageinfo_free(e, 0);
  }
  /**
   * @returns {number}
   */
  get page_off() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    return p(this.__wbg_ptr), c.pageinfo_page_off(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {number}
   */
  get width_pt() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    return p(this.__wbg_ptr), c.pageinfo_width_pt(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get height_pt() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    return p(this.__wbg_ptr), c.pageinfo_height_pt(this.__wbg_ptr);
  }
}
const gt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => c.__wbg_pagesinfo_free(n >>> 0, 1));
class ve {
  constructor() {
    throw new Error("cannot invoke `new` directly");
  }
  static __wrap(e) {
    e = e >>> 0;
    const t = Object.create(ve.prototype);
    return t.__wbg_ptr = e, gt.register(t, t.__wbg_ptr, t), t;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, gt.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    c.__wbg_pagesinfo_free(e, 0);
  }
  /**
   * @returns {number}
   */
  get page_count() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    return p(this.__wbg_ptr), c.pagesinfo_page_count(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} num
   * @returns {PageInfo | undefined}
   */
  page_by_number(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr), p(e);
    const t = c.pagesinfo_page_by_number(this.__wbg_ptr, e);
    return t === 0 ? void 0 : ce.__wrap(t);
  }
  /**
   * @param {number} i
   * @returns {PageInfo}
   */
  page(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr), p(e);
    const t = c.pagesinfo_page(this.__wbg_ptr, e);
    return ce.__wrap(t);
  }
  /**
   * @returns {number}
   */
  width() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    return p(this.__wbg_ptr), c.pagesinfo_width(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  height() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    return p(this.__wbg_ptr), c.pagesinfo_height(this.__wbg_ptr);
  }
}
const ft = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => c.__wbg_renderpageimageoptions_free(n >>> 0, 1));
class ue {
  static __unwrap(e) {
    return e instanceof ue ? e.__destroy_into_raw() : 0;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ft.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    c.__wbg_renderpageimageoptions_free(e, 0);
  }
  constructor() {
    const e = c.renderpageimageoptions_new();
    return this.__wbg_ptr = e >>> 0, ft.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * @returns {number | undefined}
   */
  get pixel_per_pt() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const e = c.renderpageimageoptions_pixel_per_pt(this.__wbg_ptr);
    return e === 4294967297 ? void 0 : e;
  }
  /**
   * @param {number | null} [pixel_per_pt]
   */
  set pixel_per_pt(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr), L(e) || p(e), c.renderpageimageoptions_set_pixel_per_pt(this.__wbg_ptr, L(e) ? 4294967297 : Math.fround(e));
  }
  /**
   * @returns {string | undefined}
   */
  get background_color() {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const r = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr), c.renderpageimageoptions_background_color(r, this.__wbg_ptr);
      var e = m().getInt32(r + 4 * 0, !0), t = m().getInt32(r + 4 * 1, !0);
      let i;
      return e !== 0 && (i = R(e, t).slice(), c.__wbindgen_export_3(e, t * 1, 1)), i;
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string | null} [background_color]
   */
  set background_color(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    var t = L(e) ? 0 : W(e, c.__wbindgen_export_1, c.__wbindgen_export_2), r = O;
    c.renderpageimageoptions_set_background_color(this.__wbg_ptr, t, r);
  }
  /**
   * @returns {number}
   */
  get page_off() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    return p(this.__wbg_ptr), c.renderpageimageoptions_page_off(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} page_off
   */
  set page_off(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr), p(e), c.renderpageimageoptions_set_page_off(this.__wbg_ptr, e);
  }
  /**
   * @returns {string | undefined}
   */
  get cache_key() {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const r = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr), c.renderpageimageoptions_cache_key(r, this.__wbg_ptr);
      var e = m().getInt32(r + 4 * 0, !0), t = m().getInt32(r + 4 * 1, !0);
      let i;
      return e !== 0 && (i = R(e, t).slice(), c.__wbindgen_export_3(e, t * 1, 1)), i;
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string | null} [cache_key]
   */
  set cache_key(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    var t = L(e) ? 0 : W(e, c.__wbindgen_export_1, c.__wbindgen_export_2), r = O;
    c.renderpageimageoptions_set_cache_key(this.__wbg_ptr, t, r);
  }
  /**
   * @returns {number | undefined}
   */
  get data_selection() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const e = c.renderpageimageoptions_data_selection(this.__wbg_ptr);
    return e === 4294967297 ? void 0 : e;
  }
  /**
   * @param {number | null} [data_selection]
   */
  set data_selection(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr), L(e) || p(e), c.renderpageimageoptions_set_data_selection(this.__wbg_ptr, L(e) ? 4294967297 : e >>> 0);
  }
}
const wt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => c.__wbg_rendersession_free(n >>> 0, 1));
class N {
  constructor() {
    throw new Error("cannot invoke `new` directly");
  }
  static __wrap(e) {
    e = e >>> 0;
    const t = Object.create(N.prototype);
    return t.__wbg_ptr = e, wt.register(t, t.__wbg_ptr, t), t;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, wt.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    c.__wbg_rendersession_free(e, 0);
  }
  /**
   * @param {number} rect_lo_x
   * @param {number} rect_lo_y
   * @param {number} rect_hi_x
   * @param {number} rect_hi_y
   * @returns {string}
   */
  render_in_window(e, t, r, i) {
    let s, o;
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const d = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr), c.rendersession_render_in_window(d, this.__wbg_ptr, e, t, r, i);
      var a = m().getInt32(d + 4 * 0, !0), u = m().getInt32(d + 4 * 1, !0);
      return s = a, o = u, R(a, u);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16), c.__wbindgen_export_3(s, o, 1);
    }
  }
  /**
   * @returns {number | undefined}
   */
  get pixel_per_pt() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const e = c.renderpageimageoptions_pixel_per_pt(this.__wbg_ptr);
    return e === 4294967297 ? void 0 : e;
  }
  /**
   * @param {number | null} [pixel_per_pt]
   */
  set pixel_per_pt(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr), L(e) || p(e), c.renderpageimageoptions_set_pixel_per_pt(this.__wbg_ptr, L(e) ? 4294967297 : Math.fround(e));
  }
  /**
   * @returns {string | undefined}
   */
  get background_color() {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const r = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr), c.rendersession_background_color(r, this.__wbg_ptr);
      var e = m().getInt32(r + 4 * 0, !0), t = m().getInt32(r + 4 * 1, !0);
      let i;
      return e !== 0 && (i = R(e, t).slice(), c.__wbindgen_export_3(e, t * 1, 1)), i;
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string | null} [background_color]
   */
  set background_color(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    var t = L(e) ? 0 : W(e, c.__wbindgen_export_1, c.__wbindgen_export_2), r = O;
    c.rendersession_set_background_color(this.__wbg_ptr, t, r);
  }
  /**
   * @returns {PagesInfo}
   */
  get pages_info() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const e = c.rendersession_pages_info(this.__wbg_ptr);
    return ve.__wrap(e);
  }
  /**
   * @returns {number}
   */
  get doc_width() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    return p(this.__wbg_ptr), c.rendersession_doc_width(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get doc_height() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    return p(this.__wbg_ptr), c.rendersession_doc_height(this.__wbg_ptr);
  }
  /**
   * @param {Uint32Array} path
   * @returns {string | undefined}
   */
  source_span(e) {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const o = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr);
      const a = fn(e, c.__wbindgen_export_1), u = O;
      c.rendersession_source_span(o, this.__wbg_ptr, a, u);
      var t = m().getInt32(o + 4 * 0, !0), r = m().getInt32(o + 4 * 1, !0), i = m().getInt32(o + 4 * 2, !0), s = m().getInt32(o + 4 * 3, !0);
      if (s)
        throw M(i);
      let d;
      return t !== 0 && (d = R(t, r).slice(), c.__wbindgen_export_3(t, r * 1, 1)), d;
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
}
const ht = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => c.__wbg_rendersessionoptions_free(n >>> 0, 1));
class mn {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, ht.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    c.__wbg_rendersessionoptions_free(e, 0);
  }
  constructor() {
    const e = c.rendersessionoptions_new();
    return this.__wbg_ptr = e >>> 0, ht.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * @returns {number | undefined}
   */
  get pixel_per_pt() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const e = c.renderpageimageoptions_pixel_per_pt(this.__wbg_ptr);
    return e === 4294967297 ? void 0 : e;
  }
  /**
   * @param {number | null} [pixel_per_pt]
   */
  set pixel_per_pt(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr), L(e) || p(e), c.renderpageimageoptions_set_pixel_per_pt(this.__wbg_ptr, L(e) ? 4294967297 : Math.fround(e));
  }
  /**
   * @returns {string | undefined}
   */
  get background_color() {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const r = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr), c.rendersessionoptions_background_color(r, this.__wbg_ptr);
      var e = m().getInt32(r + 4 * 0, !0), t = m().getInt32(r + 4 * 1, !0);
      let i;
      return e !== 0 && (i = R(e, t).slice(), c.__wbindgen_export_3(e, t * 1, 1)), i;
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string | null} [background_color]
   */
  set background_color(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    var t = L(e) ? 0 : W(e, c.__wbindgen_export_1, c.__wbindgen_export_2), r = O;
    c.rendersessionoptions_set_background_color(this.__wbg_ptr, t, r);
  }
  /**
   * @returns {string | undefined}
   */
  get format() {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const r = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr), c.rendersessionoptions_format(r, this.__wbg_ptr);
      var e = m().getInt32(r + 4 * 0, !0), t = m().getInt32(r + 4 * 1, !0);
      let i;
      return e !== 0 && (i = R(e, t).slice(), c.__wbindgen_export_3(e, t * 1, 1)), i;
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string | null} [format]
   */
  set format(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    var t = L(e) ? 0 : W(e, c.__wbindgen_export_1, c.__wbindgen_export_2), r = O;
    c.rendersessionoptions_set_format(this.__wbg_ptr, t, r);
  }
}
const Fe = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => c.__wbg_typstrenderer_free(n >>> 0, 1));
class Se {
  static __wrap(e) {
    e = e >>> 0;
    const t = Object.create(Se.prototype);
    return t.__wbg_ptr = e, Fe.register(t, t.__wbg_ptr, t), t;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Fe.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    c.__wbg_typstrenderer_free(e, 0);
  }
  /**
   * @param {any} _w
   * @returns {Promise<TypstWorker>}
   */
  create_worker(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const t = c.typstrenderer_create_worker(this.__wbg_ptr, y(e));
    return M(t);
  }
  /**
   * @returns {WorkerBridge}
   */
  create_worker_bridge() {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const i = this.__destroy_into_raw(), s = c.__wbindgen_add_to_stack_pointer(-16);
      p(i), c.typstrenderer_create_worker_bridge(s, i);
      var e = m().getInt32(s + 4 * 0, !0), t = m().getInt32(s + 4 * 1, !0), r = m().getInt32(s + 4 * 2, !0);
      if (r)
        throw M(t);
      return Ce.__wrap(e);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {RenderSession} ses
   * @param {HTMLElement} elem
   * @returns {Promise<IncrDomDocClient>}
   */
  mount_dom(e, t) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    if (p(this.__wbg_ptr), H(e, N), e.__wbg_ptr === 0)
      throw new Error("Attempt to use a moved value");
    const r = c.typstrenderer_mount_dom(this.__wbg_ptr, e.__wbg_ptr, y(t));
    return M(r);
  }
  constructor() {
    const e = c.typstrenderer_new();
    return this.__wbg_ptr = e >>> 0, Fe.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * @param {CreateSessionOptions | null} [options]
   * @returns {RenderSession}
   */
  create_session(e) {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const s = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr);
      let o = 0;
      if (!L(e)) {
        if (H(e, qt), e.__wbg_ptr === 0)
          throw new Error("Attempt to use a moved value");
        o = e.__destroy_into_raw();
      }
      c.typstrenderer_create_session(s, this.__wbg_ptr, o);
      var t = m().getInt32(s + 4 * 0, !0), r = m().getInt32(s + 4 * 1, !0), i = m().getInt32(s + 4 * 2, !0);
      if (i)
        throw M(r);
      return N.__wrap(t);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {RenderSession} session
   */
  reset(e) {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const i = c.__wbindgen_add_to_stack_pointer(-16);
      if (p(this.__wbg_ptr), H(e, N), e.__wbg_ptr === 0)
        throw new Error("Attempt to use a moved value");
      c.typstrenderer_reset(i, this.__wbg_ptr, e.__wbg_ptr);
      var t = m().getInt32(i + 4 * 0, !0), r = m().getInt32(i + 4 * 1, !0);
      if (r)
        throw M(t);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {RenderSession} session
   * @param {string} action
   * @param {Uint8Array} data
   */
  manipulate_data(e, t, r) {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const o = c.__wbindgen_add_to_stack_pointer(-16);
      if (p(this.__wbg_ptr), H(e, N), e.__wbg_ptr === 0)
        throw new Error("Attempt to use a moved value");
      const a = W(t, c.__wbindgen_export_1, c.__wbindgen_export_2), u = O, d = me(r, c.__wbindgen_export_1), f = O;
      c.typstrenderer_manipulate_data(o, this.__wbg_ptr, e.__wbg_ptr, a, u, d, f);
      var i = m().getInt32(o + 4 * 0, !0), s = m().getInt32(o + 4 * 1, !0);
      if (s)
        throw M(i);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} artifact_content
   * @param {string} decoder
   * @returns {RenderSession}
   */
  session_from_artifact(e, t) {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const o = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr);
      const a = me(e, c.__wbindgen_export_1), u = O, d = W(t, c.__wbindgen_export_1, c.__wbindgen_export_2), f = O;
      c.typstrenderer_session_from_artifact(o, this.__wbg_ptr, a, u, d, f);
      var r = m().getInt32(o + 4 * 0, !0), i = m().getInt32(o + 4 * 1, !0), s = m().getInt32(o + 4 * 2, !0);
      if (s)
        throw M(i);
      return N.__wrap(r);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {any} _v
   */
  load_glyph_pack(e) {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const i = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr), c.typstrenderer_load_glyph_pack(i, this.__wbg_ptr, y(e));
      var t = m().getInt32(i + 4 * 0, !0), r = m().getInt32(i + 4 * 1, !0);
      if (r)
        throw M(t);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {RenderSession} session
   * @param {number} rect_lo_x
   * @param {number} rect_lo_y
   * @param {number} rect_hi_x
   * @param {number} rect_hi_y
   * @returns {string}
   */
  render_svg_diff(e, t, r, i, s) {
    let o, a;
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const f = c.__wbindgen_add_to_stack_pointer(-16);
      if (p(this.__wbg_ptr), H(e, N), e.__wbg_ptr === 0)
        throw new Error("Attempt to use a moved value");
      c.typstrenderer_render_svg_diff(f, this.__wbg_ptr, e.__wbg_ptr, t, r, i, s);
      var u = m().getInt32(f + 4 * 0, !0), d = m().getInt32(f + 4 * 1, !0);
      return o = u, a = d, R(u, d);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16), c.__wbindgen_export_3(o, a, 1);
    }
  }
  /**
   * @param {RenderSession} session
   * @param {number | null} [parts]
   * @returns {string}
   */
  svg_data(e, t) {
    let r, i;
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const w = c.__wbindgen_add_to_stack_pointer(-16);
      if (p(this.__wbg_ptr), H(e, N), e.__wbg_ptr === 0)
        throw new Error("Attempt to use a moved value");
      L(t) || p(t), c.typstrenderer_svg_data(w, this.__wbg_ptr, e.__wbg_ptr, L(t) ? 4294967297 : t >>> 0);
      var s = m().getInt32(w + 4 * 0, !0), o = m().getInt32(w + 4 * 1, !0), a = m().getInt32(w + 4 * 2, !0), u = m().getInt32(w + 4 * 3, !0), d = s, f = o;
      if (u)
        throw d = 0, f = 0, M(a);
      return r = d, i = f, R(d, f);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16), c.__wbindgen_export_3(r, i, 1);
    }
  }
  /**
   * @param {RenderSession} session
   * @returns {Array<any> | undefined}
   */
  get_customs(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    if (p(this.__wbg_ptr), H(e, N), e.__wbg_ptr === 0)
      throw new Error("Attempt to use a moved value");
    const t = c.typstrenderer_get_customs(this.__wbg_ptr, e.__wbg_ptr);
    return M(t);
  }
  /**
   * @param {RenderSession} session
   * @param {HTMLElement} root
   * @returns {boolean}
   */
  render_svg(e, t) {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const o = c.__wbindgen_add_to_stack_pointer(-16);
      if (p(this.__wbg_ptr), H(e, N), e.__wbg_ptr === 0)
        throw new Error("Attempt to use a moved value");
      c.typstrenderer_render_svg(o, this.__wbg_ptr, e.__wbg_ptr, y(t));
      var r = m().getInt32(o + 4 * 0, !0), i = m().getInt32(o + 4 * 1, !0), s = m().getInt32(o + 4 * 2, !0);
      if (s)
        throw M(i);
      return r !== 0;
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {RenderSession} ses
   * @param {any} canvas
   * @param {RenderPageImageOptions | null} [options]
   * @returns {Promise<any>}
   */
  render_page_to_canvas(e, t, r) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    if (p(this.__wbg_ptr), H(e, N), e.__wbg_ptr === 0)
      throw new Error("Attempt to use a moved value");
    let i = 0;
    if (!L(r)) {
      if (H(r, ue), r.__wbg_ptr === 0)
        throw new Error("Attempt to use a moved value");
      i = r.__destroy_into_raw();
    }
    const s = c.typstrenderer_render_page_to_canvas(this.__wbg_ptr, e.__wbg_ptr, y(t), i);
    return M(s);
  }
}
const pt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => c.__wbg_typstrendererbuilder_free(n >>> 0, 1));
class yn {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, pt.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    c.__wbg_typstrendererbuilder_free(e, 0);
  }
  constructor() {
    try {
      const i = c.__wbindgen_add_to_stack_pointer(-16);
      c.typstrendererbuilder_new(i);
      var e = m().getInt32(i + 4 * 0, !0), t = m().getInt32(i + 4 * 1, !0), r = m().getInt32(i + 4 * 2, !0);
      if (r)
        throw M(t);
      return this.__wbg_ptr = e >>> 0, pt.register(this, this.__wbg_ptr, this), this;
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Promise<TypstRenderer>}
   */
  build() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    const e = this.__destroy_into_raw();
    p(e);
    const t = c.typstrendererbuilder_build(e);
    return M(t);
  }
  /**
   * @param {any} _pack
   * @returns {Promise<void>}
   */
  add_glyph_pack(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const t = c.typstrendererbuilder_add_glyph_pack(this.__wbg_ptr, y(e));
    return M(t);
  }
  /**
   * @param {Uint8Array} _font_buffer
   * @returns {Promise<void>}
   */
  add_raw_font(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const t = c.typstrendererbuilder_add_raw_font(this.__wbg_ptr, y(e));
    return M(t);
  }
  /**
   * @param {Array<any>} _fonts
   * @returns {Promise<void>}
   */
  add_web_fonts(e) {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const t = c.typstrendererbuilder_add_web_fonts(this.__wbg_ptr, y(e));
    return M(t);
  }
}
const vn = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => c.__wbg_typstworker_free(n >>> 0, 1));
class Sn {
  constructor() {
    throw new Error("cannot invoke `new` directly");
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, vn.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    c.__wbg_typstworker_free(e, 0);
  }
  /**
   * @param {string} _action
   * @param {Uint8Array} _data
   * @returns {Promise<any>}
   */
  manipulate_data(e, t) {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const o = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr);
      const a = W(e, c.__wbindgen_export_1, c.__wbindgen_export_2), u = O;
      c.typstworker_manipulate_data(o, this.__wbg_ptr, a, u, y(t));
      var r = m().getInt32(o + 4 * 0, !0), i = m().getInt32(o + 4 * 1, !0), s = m().getInt32(o + 4 * 2, !0);
      if (s)
        throw M(i);
      return M(r);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Promise<any>}
   */
  get_pages_info() {
    if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
    p(this.__wbg_ptr);
    const e = c.typstworker_get_pages_info(this.__wbg_ptr);
    return M(e);
  }
  /**
   * @param {Uint8Array} _actions
   * @param {HTMLCanvasElement[]} _canvas_list
   * @param {RenderPageImageOptions[]} _data
   * @returns {Promise<any>}
   */
  render_canvas(e, t, r) {
    try {
      if (this.__wbg_ptr == 0) throw new Error("Attempt to use a moved value");
      const a = c.__wbindgen_add_to_stack_pointer(-16);
      p(this.__wbg_ptr);
      const u = me(e, c.__wbindgen_export_1), d = O, f = ct(t, c.__wbindgen_export_1), w = O, x = ct(r, c.__wbindgen_export_1), C = O;
      c.typstworker_render_canvas(a, this.__wbg_ptr, u, d, f, w, x, C);
      var i = m().getInt32(a + 4 * 0, !0), s = m().getInt32(a + 4 * 1, !0), o = m().getInt32(a + 4 * 2, !0);
      if (o)
        throw M(s);
      return M(i);
    } finally {
      c.__wbindgen_add_to_stack_pointer(16);
    }
  }
}
const bt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => c.__wbg_workerbridge_free(n >>> 0, 1));
class Ce {
  constructor() {
    throw new Error("cannot invoke `new` directly");
  }
  static __wrap(e) {
    e = e >>> 0;
    const t = Object.create(Ce.prototype);
    return t.__wbg_ptr = e, bt.register(t, t.__wbg_ptr, t), t;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, bt.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    c.__wbg_workerbridge_free(e, 0);
  }
}
async function Cn(n, e) {
  if (typeof Response == "function" && n instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(n, e);
      } catch (r) {
        if (n.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", r);
        else
          throw r;
      }
    const t = await n.arrayBuffer();
    return await WebAssembly.instantiate(t, e);
  } else {
    const t = await WebAssembly.instantiate(n, e);
    return t instanceof WebAssembly.Instance ? { instance: t, module: n } : t;
  }
}
function Nt() {
  const n = {};
  return n.wbg = {}, n.wbg.__wbg_appendChild_8204974b7328bf98 = function() {
    return k(function(e, t) {
      const r = _(e).appendChild(_(t));
      return y(r);
    }, arguments);
  }, n.wbg.__wbg_buffer_609cc3eee51ed158 = function() {
    return h(function(e) {
      const t = _(e).buffer;
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return k(function(e, t) {
      const r = _(e).call(_(t));
      return y(r);
    }, arguments);
  }, n.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return k(function(e, t, r) {
      const i = _(e).call(_(t), _(r));
      return y(i);
    }, arguments);
  }, n.wbg.__wbg_call_833bed5770ea2041 = function() {
    return k(function(e, t, r, i) {
      const s = _(e).call(_(t), _(r), _(i));
      return y(s);
    }, arguments);
  }, n.wbg.__wbg_call_b8adc8b1d0a0d8eb = function() {
    return k(function(e, t, r, i, s) {
      const o = _(e).call(_(t), _(r), _(i), _(s));
      return y(o);
    }, arguments);
  }, n.wbg.__wbg_clearRect_8e4ba7ea0e06711a = function() {
    return h(function(e, t, r, i, s) {
      _(e).clearRect(t, r, i, s);
    }, arguments);
  }, n.wbg.__wbg_clientWidth_ce67a04dc15fce39 = function() {
    return h(function(e) {
      const t = _(e).clientWidth;
      return p(t), t;
    }, arguments);
  }, n.wbg.__wbg_clip_8e8cfb00a055cd03 = function() {
    return h(function(e, t) {
      _(e).clip(_(t));
    }, arguments);
  }, n.wbg.__wbg_clip_f584e320f8a2b022 = function() {
    return h(function(e, t) {
      _(e).clip(_(t));
    }, arguments);
  }, n.wbg.__wbg_cloneNode_e35b333b87d51340 = function() {
    return k(function(e) {
      const t = _(e).cloneNode();
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_content_537e4105afcd9cee = function() {
    return h(function(e) {
      const t = _(e).content;
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_createElement_8c9931a732ee2fea = function() {
    return k(function(e, t, r) {
      const i = _(e).createElement(R(t, r));
      return y(i);
    }, arguments);
  }, n.wbg.__wbg_createImageBitmap_705010fb21a22922 = function() {
    return k(function(e, t) {
      const r = _(e).createImageBitmap(_(t));
      return y(r);
    }, arguments);
  }, n.wbg.__wbg_createImageBitmap_b814e27800576bdb = function() {
    return k(function(e, t) {
      const r = _(e).createImageBitmap(_(t));
      return y(r);
    }, arguments);
  }, n.wbg.__wbg_createObjectURL_6e98d2f9c7bd9764 = function() {
    return k(function(e, t) {
      const r = URL.createObjectURL(_(t)), i = W(r, c.__wbindgen_export_1, c.__wbindgen_export_2), s = O;
      m().setInt32(e + 4 * 1, s, !0), m().setInt32(e + 4 * 0, i, !0);
    }, arguments);
  }, n.wbg.__wbg_document_d249400bd7bd996d = function() {
    return h(function(e) {
      const t = _(e).document;
      return L(t) ? 0 : y(t);
    }, arguments);
  }, n.wbg.__wbg_drawImage_0915f348c5d54848 = function() {
    return k(function(e, t, r, i) {
      _(e).drawImage(_(t), r, i);
    }, arguments);
  }, n.wbg.__wbg_drawImage_16485aae76d89dbf = function() {
    return k(function(e, t, r, i, s, o) {
      _(e).drawImage(_(t), r, i, s, o);
    }, arguments);
  }, n.wbg.__wbg_drawImage_468585e3ecfa189a = function() {
    return k(function(e, t, r, i, s, o) {
      _(e).drawImage(_(t), r, i, s, o);
    }, arguments);
  }, n.wbg.__wbg_drawImage_472a4d5b6df3739a = function() {
    return k(function(e, t, r, i) {
      _(e).drawImage(_(t), r, i);
    }, arguments);
  }, n.wbg.__wbg_drawImage_473e6602e24e18aa = function() {
    return k(function(e, t, r, i) {
      _(e).drawImage(_(t), r, i);
    }, arguments);
  }, n.wbg.__wbg_drawImage_86fd8465c00c7bc6 = function() {
    return k(function(e, t, r, i, s, o) {
      _(e).drawImage(_(t), r, i, s, o);
    }, arguments);
  }, n.wbg.__wbg_drawImage_ff273710b96c85cc = function() {
    return k(function(e, t, r, i, s, o) {
      _(e).drawImage(_(t), r, i, s, o);
    }, arguments);
  }, n.wbg.__wbg_error_7534b8e9a36f1ab4 = function() {
    return h(function(e, t) {
      let r, i;
      try {
        r = e, i = t, console.error(R(e, t));
      } finally {
        c.__wbindgen_export_3(r, i, 1);
      }
    }, arguments);
  }, n.wbg.__wbg_fillRect_b1529535ac758d4c = function() {
    return h(function(e, t, r, i, s) {
      _(e).fillRect(t, r, i, s);
    }, arguments);
  }, n.wbg.__wbg_fillRect_c38d5d56492a2368 = function() {
    return h(function(e, t, r, i, s) {
      _(e).fillRect(t, r, i, s);
    }, arguments);
  }, n.wbg.__wbg_fill_51814702df845abd = function() {
    return h(function(e, t, r) {
      _(e).fill(_(t), _t[r]);
    }, arguments);
  }, n.wbg.__wbg_fill_5d26765e6d1d8f6b = function() {
    return h(function(e, t) {
      _(e).fill(_(t));
    }, arguments);
  }, n.wbg.__wbg_fill_64902335a40baa8d = function() {
    return h(function(e, t, r) {
      _(e).fill(_(t), _t[r]);
    }, arguments);
  }, n.wbg.__wbg_fill_cbb22e6ac4da5b1b = function() {
    return h(function(e, t) {
      _(e).fill(_(t));
    }, arguments);
  }, n.wbg.__wbg_firstElementChild_21331181ca115bcc = function() {
    return h(function(e) {
      const t = _(e).firstElementChild;
      return L(t) ? 0 : y(t);
    }, arguments);
  }, n.wbg.__wbg_firstElementChild_d75d385f5abd1414 = function() {
    return h(function(e) {
      const t = _(e).firstElementChild;
      return L(t) ? 0 : y(t);
    }, arguments);
  }, n.wbg.__wbg_getAttribute_ea5166be2deba45e = function() {
    return h(function(e, t, r, i) {
      const s = _(t).getAttribute(R(r, i));
      var o = L(s) ? 0 : W(s, c.__wbindgen_export_1, c.__wbindgen_export_2), a = O;
      m().setInt32(e + 4 * 1, a, !0), m().setInt32(e + 4 * 0, o, !0);
    }, arguments);
  }, n.wbg.__wbg_getContext_e9cf379449413580 = function() {
    return k(function(e, t, r) {
      const i = _(e).getContext(R(t, r));
      return L(i) ? 0 : y(i);
    }, arguments);
  }, n.wbg.__wbg_getContext_f65a0debd1e8f8e8 = function() {
    return k(function(e, t, r) {
      const i = _(e).getContext(R(t, r));
      return L(i) ? 0 : y(i);
    }, arguments);
  }, n.wbg.__wbg_get_67b2ba62fc30de12 = function() {
    return k(function(e, t) {
      const r = Reflect.get(_(e), _(t));
      return y(r);
    }, arguments);
  }, n.wbg.__wbg_globalCompositeOperation_154b0f30008caa5e = function() {
    return k(function(e, t) {
      const r = _(t).globalCompositeOperation, i = W(r, c.__wbindgen_export_1, c.__wbindgen_export_2), s = O;
      m().setInt32(e + 4 * 1, s, !0), m().setInt32(e + 4 * 0, i, !0);
    }, arguments);
  }, n.wbg.__wbg_globalCompositeOperation_1f405e2ef7c5118b = function() {
    return k(function(e, t) {
      const r = _(t).globalCompositeOperation, i = W(r, c.__wbindgen_export_1, c.__wbindgen_export_2), s = O;
      m().setInt32(e + 4 * 1, s, !0), m().setInt32(e + 4 * 0, i, !0);
    }, arguments);
  }, n.wbg.__wbg_height_d3f39e12f0f62121 = function() {
    return h(function(e) {
      const t = _(e).height;
      return p(t), t;
    }, arguments);
  }, n.wbg.__wbg_incrdomdocclient_new = function() {
    return h(function(e) {
      const t = ye.__wrap(e);
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_instanceof_CanvasRenderingContext2d_df82a4d3437bf1cc = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof CanvasRenderingContext2D;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_Element_0af65443936d5154 = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof Element;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_HtmlCanvasElement_2ea67072a7624ac5 = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof HTMLCanvasElement;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_HtmlDivElement_dbc6eb62eb772174 = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof HTMLDivElement;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_HtmlElement_51378c201250b16c = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof HTMLElement;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_HtmlTemplateElement_7929a67c77198607 = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof HTMLTemplateElement;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_ImageBitmap_d093d508663e313d = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof ImageBitmap;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_OffscreenCanvasRenderingContext2d_a070fdde7ba760a3 = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof OffscreenCanvasRenderingContext2D;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_OffscreenCanvas_d55760945f91bf51 = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof OffscreenCanvas;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_Promise_935168b8f4b49db3 = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof Promise;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_SvgGraphicsElement_8b2cbd8116680c53 = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof SVGGraphicsElement;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_SvgsvgElement_6a0d878e0d0f979c = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof SVGSVGElement;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_Window_def73ea0955fc569 = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof Window;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_instanceof_WorkerGlobalScope_dbdbdea7e3b56493 = function() {
    return h(function(e) {
      let t;
      try {
        t = _(e) instanceof WorkerGlobalScope;
      } catch {
        t = !1;
      }
      const r = t;
      return j(r), r;
    }, arguments);
  }, n.wbg.__wbg_lastElementChild_1269b660ec3e6985 = function() {
    return h(function(e) {
      const t = _(e).lastElementChild;
      return L(t) ? 0 : y(t);
    }, arguments);
  }, n.wbg.__wbg_length_a446193dc22c12f8 = function() {
    return h(function(e) {
      const t = _(e).length;
      return p(t), t;
    }, arguments);
  }, n.wbg.__wbg_log_1ae1e9f741096e91 = function() {
    return h(function(e, t) {
      console.log(_(e), _(t));
    }, arguments);
  }, n.wbg.__wbg_log_c222819a41e063d3 = function() {
    return h(function(e) {
      console.log(_(e));
    }, arguments);
  }, n.wbg.__wbg_measureText_f0f078704231c37f = function() {
    return k(function(e, t, r) {
      const i = _(e).measureText(R(t, r));
      return y(i);
    }, arguments);
  }, n.wbg.__wbg_new_23a2665fac83c611 = function() {
    return h(function(e, t) {
      try {
        var r = { a: e, b: t }, i = (o, a) => {
          const u = r.a;
          r.a = 0;
          try {
            return bn(u, r.b, o, a);
          } finally {
            r.a = u;
          }
        };
        const s = new Promise(i);
        return y(s);
      } finally {
        r.a = r.b = 0;
      }
    }, arguments);
  }, n.wbg.__wbg_new_2ef971087cb43792 = function() {
    return k(function(e, t) {
      const r = new OffscreenCanvas(e >>> 0, t >>> 0);
      return y(r);
    }, arguments);
  }, n.wbg.__wbg_new_405e22f390576ce2 = function() {
    return h(function() {
      const e = new Object();
      return y(e);
    }, arguments);
  }, n.wbg.__wbg_new_6377da097a44ce6e = function() {
    return k(function() {
      const e = new Image();
      return y(e);
    }, arguments);
  }, n.wbg.__wbg_new_78feb108b6472713 = function() {
    return h(function() {
      const e = new Array();
      return y(e);
    }, arguments);
  }, n.wbg.__wbg_new_8a6f238a6ece86ea = function() {
    return h(function() {
      const e = new Error();
      return y(e);
    }, arguments);
  }, n.wbg.__wbg_new_a12002a7f91c75be = function() {
    return h(function(e) {
      const t = new Uint8Array(_(e));
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_new_c68d7209be747379 = function() {
    return h(function(e, t) {
      const r = new Error(R(e, t));
      return y(r);
    }, arguments);
  }, n.wbg.__wbg_newnoargs_105ed471475aaf50 = function() {
    return h(function(e, t) {
      const r = new Function(R(e, t));
      return y(r);
    }, arguments);
  }, n.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function() {
    return h(function(e, t, r) {
      const i = new Uint8Array(_(e), t >>> 0, r >>> 0);
      return y(i);
    }, arguments);
  }, n.wbg.__wbg_newwithlength_a381634e90c276d4 = function() {
    return h(function(e) {
      const t = new Uint8Array(e >>> 0);
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_newwithpathstring_e9586ab3affcd4fd = function() {
    return k(function(e, t) {
      const r = new Path2D(R(e, t));
      return y(r);
    }, arguments);
  }, n.wbg.__wbg_newwithu8arraysequenceandoptions_068570c487f69127 = function() {
    return k(function(e, t) {
      const r = new Blob(_(e), _(t));
      return y(r);
    }, arguments);
  }, n.wbg.__wbg_nextElementSibling_8472709bec4de113 = function() {
    return h(function(e) {
      const t = _(e).nextElementSibling;
      return L(t) ? 0 : y(t);
    }, arguments);
  }, n.wbg.__wbg_push_737cfc8c1432c2c6 = function() {
    return h(function(e, t) {
      const r = _(e).push(_(t));
      return p(r), r;
    }, arguments);
  }, n.wbg.__wbg_putImageData_4c5aa10f3b3e4924 = function() {
    return k(function(e, t, r, i) {
      _(e).putImageData(_(t), r, i);
    }, arguments);
  }, n.wbg.__wbg_putImageData_6d5d5ef6ee83898b = function() {
    return k(function(e, t, r, i) {
      _(e).putImageData(_(t), r, i);
    }, arguments);
  }, n.wbg.__wbg_queueMicrotask_97d92b4fcc8a61c5 = function() {
    return h(function(e) {
      queueMicrotask(_(e));
    }, arguments);
  }, n.wbg.__wbg_queueMicrotask_d3219def82552485 = function() {
    return h(function(e) {
      const t = _(e).queueMicrotask;
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_removeProperty_0e85471f4dfc00ae = function() {
    return k(function(e, t, r, i) {
      const s = _(t).removeProperty(R(r, i)), o = W(s, c.__wbindgen_export_1, c.__wbindgen_export_2), a = O;
      m().setInt32(e + 4 * 1, a, !0), m().setInt32(e + 4 * 0, o, !0);
    }, arguments);
  }, n.wbg.__wbg_remove_e2d2659f3128c045 = function() {
    return h(function(e) {
      _(e).remove();
    }, arguments);
  }, n.wbg.__wbg_renderpageimageoptions_unwrap = function() {
    return h(function(e) {
      const t = ue.__unwrap(M(e));
      return p(t), t;
    }, arguments);
  }, n.wbg.__wbg_replaceWith_9ce9927e3141d0f6 = function() {
    return k(function(e, t) {
      _(e).replaceWith(_(t));
    }, arguments);
  }, n.wbg.__wbg_resolve_4851785c9c5f573d = function() {
    return h(function(e) {
      const t = Promise.resolve(_(e));
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_restore_1ef50af0835a4649 = function() {
    return h(function(e) {
      _(e).restore();
    }, arguments);
  }, n.wbg.__wbg_restore_cc5ae2746f7b5043 = function() {
    return h(function(e) {
      _(e).restore();
    }, arguments);
  }, n.wbg.__wbg_revokeObjectURL_27267efebeb457c7 = function() {
    return k(function(e, t) {
      URL.revokeObjectURL(R(e, t));
    }, arguments);
  }, n.wbg.__wbg_save_5f563096e64939da = function() {
    return h(function(e) {
      _(e).save();
    }, arguments);
  }, n.wbg.__wbg_save_c675a7a4bbd44e4a = function() {
    return h(function(e) {
      _(e).save();
    }, arguments);
  }, n.wbg.__wbg_setAttribute_2704501201f15687 = function() {
    return k(function(e, t, r, i, s) {
      _(e).setAttribute(R(t, r), R(i, s));
    }, arguments);
  }, n.wbg.__wbg_setLineDash_0e3f3e194352a774 = function() {
    return k(function(e, t) {
      _(e).setLineDash(_(t));
    }, arguments);
  }, n.wbg.__wbg_setLineDash_325e094206df53e9 = function() {
    return k(function(e, t) {
      _(e).setLineDash(_(t));
    }, arguments);
  }, n.wbg.__wbg_setProperty_f2cf326652b9a713 = function() {
    return k(function(e, t, r, i, s) {
      _(e).setProperty(R(t, r), R(i, s));
    }, arguments);
  }, n.wbg.__wbg_setTransform_8c4d954cafb34b75 = function() {
    return k(function(e, t, r, i, s, o, a) {
      _(e).setTransform(t, r, i, s, o, a);
    }, arguments);
  }, n.wbg.__wbg_setTransform_da2f0baec3f09522 = function() {
    return k(function(e, t, r, i, s, o, a) {
      _(e).setTransform(t, r, i, s, o, a);
    }, arguments);
  }, n.wbg.__wbg_set_37837023f3d740e8 = function() {
    return h(function(e, t, r) {
      _(e)[t >>> 0] = M(r);
    }, arguments);
  }, n.wbg.__wbg_set_65595bdd868b3009 = function() {
    return h(function(e, t, r) {
      _(e).set(_(t), r >>> 0);
    }, arguments);
  }, n.wbg.__wbg_set_bb8cecf6a62b9f46 = function() {
    return k(function(e, t, r) {
      const i = Reflect.set(_(e), _(t), _(r));
      return j(i), i;
    }, arguments);
  }, n.wbg.__wbg_setfillStyle_2205fca942c641ba = function() {
    return h(function(e, t, r) {
      _(e).fillStyle = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setfillStyle_cb059a69ce15cc28 = function() {
    return h(function(e, t, r) {
      _(e).fillStyle = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setfont_4c3584ef2f5c9f7e = function() {
    return h(function(e, t, r) {
      _(e).font = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setglobalCompositeOperation_9a7a92bac2fb7ffd = function() {
    return k(function(e, t, r) {
      _(e).globalCompositeOperation = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setglobalCompositeOperation_b000e874f8f4a9d3 = function() {
    return k(function(e, t, r) {
      _(e).globalCompositeOperation = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setheight_da683a33fa99843c = function() {
    return h(function(e, t) {
      _(e).height = t >>> 0;
    }, arguments);
  }, n.wbg.__wbg_setinnerHTML_31bde41f835786f7 = function() {
    return h(function(e, t, r) {
      _(e).innerHTML = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setlineCap_3a3987ad3f03b31d = function() {
    return h(function(e, t, r) {
      _(e).lineCap = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setlineCap_52b6d742c95a5630 = function() {
    return h(function(e, t, r) {
      _(e).lineCap = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setlineDashOffset_030d80d07cd52ee4 = function() {
    return h(function(e, t) {
      _(e).lineDashOffset = t;
    }, arguments);
  }, n.wbg.__wbg_setlineDashOffset_59f274962f6a0553 = function() {
    return h(function(e, t) {
      _(e).lineDashOffset = t;
    }, arguments);
  }, n.wbg.__wbg_setlineJoin_79ca64e7e9efaff7 = function() {
    return h(function(e, t, r) {
      _(e).lineJoin = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setlineJoin_7e005d90ef83d627 = function() {
    return h(function(e, t, r) {
      _(e).lineJoin = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setlineWidth_3c8b7156949a9f4b = function() {
    return h(function(e, t) {
      _(e).lineWidth = t;
    }, arguments);
  }, n.wbg.__wbg_setlineWidth_ec730c524f09baa9 = function() {
    return h(function(e, t) {
      _(e).lineWidth = t;
    }, arguments);
  }, n.wbg.__wbg_setmiterLimit_26162c359bb28eb2 = function() {
    return h(function(e, t) {
      _(e).miterLimit = t;
    }, arguments);
  }, n.wbg.__wbg_setmiterLimit_9ffca64ec692501d = function() {
    return h(function(e, t) {
      _(e).miterLimit = t;
    }, arguments);
  }, n.wbg.__wbg_setonerror_e94ca1221abc457f = function() {
    return h(function(e, t) {
      _(e).onerror = _(t);
    }, arguments);
  }, n.wbg.__wbg_setonload_264a0d330b7166fb = function() {
    return h(function(e, t) {
      _(e).onload = _(t);
    }, arguments);
  }, n.wbg.__wbg_setsrc_c239193cc7ab0470 = function() {
    return h(function(e, t, r) {
      _(e).src = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setstrokeStyle_070920f27992b9a6 = function() {
    return h(function(e, t, r) {
      _(e).strokeStyle = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setstrokeStyle_415833f3f0eb5076 = function() {
    return h(function(e, t, r) {
      _(e).strokeStyle = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_settype_39ed370d3edd403c = function() {
    return h(function(e, t, r) {
      _(e).type = R(t, r);
    }, arguments);
  }, n.wbg.__wbg_setwidth_c5fed9f5e7f0b406 = function() {
    return h(function(e, t) {
      _(e).width = t >>> 0;
    }, arguments);
  }, n.wbg.__wbg_stack_0ed75d68575b0f3c = function() {
    return h(function(e, t) {
      const r = _(t).stack, i = W(r, c.__wbindgen_export_1, c.__wbindgen_export_2), s = O;
      m().setInt32(e + 4 * 1, s, !0), m().setInt32(e + 4 * 0, i, !0);
    }, arguments);
  }, n.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    return h(function() {
      const e = typeof global > "u" ? null : global;
      return L(e) ? 0 : y(e);
    }, arguments);
  }, n.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    return h(function() {
      const e = typeof globalThis > "u" ? null : globalThis;
      return L(e) ? 0 : y(e);
    }, arguments);
  }, n.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    return h(function() {
      const e = typeof self > "u" ? null : self;
      return L(e) ? 0 : y(e);
    }, arguments);
  }, n.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    return h(function() {
      const e = typeof window > "u" ? null : window;
      return L(e) ? 0 : y(e);
    }, arguments);
  }, n.wbg.__wbg_stringify_f7ed6987935b4a24 = function() {
    return k(function(e) {
      const t = JSON.stringify(_(e));
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_stroke_1b0348380fb5a54b = function() {
    return h(function(e, t) {
      _(e).stroke(_(t));
    }, arguments);
  }, n.wbg.__wbg_stroke_e9b15e77122a9be9 = function() {
    return h(function(e, t) {
      _(e).stroke(_(t));
    }, arguments);
  }, n.wbg.__wbg_style_fb30c14e5815805c = function() {
    return h(function(e) {
      const t = _(e).style;
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_then_44b73946d2fb3e7d = function() {
    return h(function(e, t) {
      const r = _(e).then(_(t));
      return y(r);
    }, arguments);
  }, n.wbg.__wbg_then_48b406749878a531 = function() {
    return h(function(e, t, r) {
      const i = _(e).then(_(t), _(r));
      return y(i);
    }, arguments);
  }, n.wbg.__wbg_transferToImageBitmap_4b1cc41c0f7e5de5 = function() {
    return k(function(e) {
      const t = _(e).transferToImageBitmap();
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_typstrenderer_new = function() {
    return h(function(e) {
      const t = Se.__wrap(e);
      return y(t);
    }, arguments);
  }, n.wbg.__wbg_warn_4ca3906c248c47c4 = function() {
    return h(function(e) {
      console.warn(_(e));
    }, arguments);
  }, n.wbg.__wbg_width_2fafd30484634e26 = function() {
    return h(function(e) {
      return _(e).width;
    }, arguments);
  }, n.wbg.__wbg_width_4f334fc47ef03de1 = function() {
    return h(function(e) {
      const t = _(e).width;
      return p(t), t;
    }, arguments);
  }, n.wbg.__wbindgen_cb_drop = function(e) {
    const t = M(e).original;
    if (t.cnt-- == 1)
      return t.a = 0, !0;
    const r = !1;
    return j(r), r;
  }, n.wbg.__wbindgen_closure_wrapper1642 = function() {
    return h(function(e, t, r) {
      const i = at(e, t, 144, wn);
      return y(i);
    }, arguments);
  }, n.wbg.__wbindgen_closure_wrapper1643 = function() {
    return h(function(e, t, r) {
      const i = at(e, t, 144, hn);
      return y(i);
    }, arguments);
  }, n.wbg.__wbindgen_closure_wrapper2286 = function() {
    return h(function(e, t, r) {
      const i = dn(e, t, 144, pn);
      return y(i);
    }, arguments);
  }, n.wbg.__wbindgen_debug_string = function(e, t) {
    const r = Ue(_(t)), i = W(r, c.__wbindgen_export_1, c.__wbindgen_export_2), s = O;
    m().setInt32(e + 4 * 1, s, !0), m().setInt32(e + 4 * 0, i, !0);
  }, n.wbg.__wbindgen_is_function = function(e) {
    const t = typeof _(e) == "function";
    return j(t), t;
  }, n.wbg.__wbindgen_is_undefined = function(e) {
    const t = _(e) === void 0;
    return j(t), t;
  }, n.wbg.__wbindgen_jsval_eq = function(e, t) {
    const r = _(e) === _(t);
    return j(r), r;
  }, n.wbg.__wbindgen_memory = function() {
    const e = c.memory;
    return y(e);
  }, n.wbg.__wbindgen_number_new = function(e) {
    return y(e);
  }, n.wbg.__wbindgen_object_clone_ref = function(e) {
    const t = _(e);
    return y(t);
  }, n.wbg.__wbindgen_object_drop_ref = function(e) {
    M(e);
  }, n.wbg.__wbindgen_string_get = function(e, t) {
    const r = _(t), i = typeof r == "string" ? r : void 0;
    var s = L(i) ? 0 : W(i, c.__wbindgen_export_1, c.__wbindgen_export_2), o = O;
    m().setInt32(e + 4 * 1, o, !0), m().setInt32(e + 4 * 0, s, !0);
  }, n.wbg.__wbindgen_string_new = function(e, t) {
    const r = R(e, t);
    return y(r);
  }, n.wbg.__wbindgen_throw = function(e, t) {
    throw new Error(R(e, t));
  }, n;
}
function Ut(n, e) {
  return c = n.exports, Ht.__wbindgen_wasm_module = e, Q = null, ne = null, re = null, c;
}
function xn(n) {
  if (c !== void 0) return c;
  typeof n < "u" && (Object.getPrototypeOf(n) === Object.prototype ? { module: n } = n : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
  const e = Nt();
  n instanceof WebAssembly.Module || (n = new WebAssembly.Module(n));
  const t = new WebAssembly.Instance(n, e);
  return Ut(t, n);
}
async function Ht(n) {
  if (c !== void 0) return c;
  typeof n < "u" && (Object.getPrototypeOf(n) === Object.prototype ? { module_or_path: n } = n : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof n > "u" && (n = Vt("typst_ts_renderer_bg.wasm", import.meta.url));
  const e = Nt();
  (typeof n == "string" || typeof Request == "function" && n instanceof Request || typeof URL == "function" && n instanceof URL) && (n = fetch(n));
  const { instance: t, module: r } = await Cn(await n, e);
  return Ut(t, r);
}
let Vt = async function(n, e) {
  throw new Error("Cannot import wasm module without importer: " + n + " " + e);
};
function Jt(n) {
  Vt = n;
}
let kn = async function(n, e) {
  const t = new Function("m", "return import(m)"), r = await t("path"), { readFileSync: i } = await t("fs"), s = new URL(r.join(r.dirname(e), n));
  return await i(s).buffer;
};
const Rn = typeof process < "u" && process.versions != null && process.versions.node != null;
Rn && Jt(kn);
const Ge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CreateSessionOptions: qt,
  IncrDomDocClient: ye,
  PageInfo: ce,
  PagesInfo: ve,
  RenderPageImageOptions: ue,
  RenderSession: N,
  RenderSessionOptions: mn,
  TypstRenderer: Se,
  TypstRendererBuilder: yn,
  TypstWorker: Sn,
  WorkerBridge: Ce,
  default: Ht,
  initSync: xn,
  renderer_build_info: ln,
  setImportWasmModule: Jt
}, Symbol.toStringTag, { value: "Module" }));
let g;
const K = new Array(128).fill(void 0);
K.push(void 0, null, !0, !1);
function b(n) {
  return K[n];
}
let ae = K.length;
function v(n) {
  ae === K.length && K.push(K.length + 1);
  const e = ae;
  return ae = K[e], K[e] = n, e;
}
function Y(n, e) {
  try {
    return n.apply(this, e);
  } catch (t) {
    g.__wbindgen_export_0(v(t));
  }
}
const Kt = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && Kt.decode();
let ie = null;
function te() {
  return (ie === null || ie.byteLength === 0) && (ie = new Uint8Array(g.memory.buffer)), ie;
}
function V(n, e) {
  return n = n >>> 0, Kt.decode(te().subarray(n, n + e));
}
function En(n) {
  n < 132 || (K[n] = ae, ae = n);
}
function I(n) {
  const e = b(n);
  return En(n), e;
}
let T = 0;
const he = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, Pn = typeof he.encodeInto == "function" ? function(n, e) {
  return he.encodeInto(n, e);
} : function(n, e) {
  const t = he.encode(n);
  return e.set(t), {
    read: n.length,
    written: t.length
  };
};
function B(n, e, t) {
  if (t === void 0) {
    const a = he.encode(n), u = e(a.length, 1) >>> 0;
    return te().subarray(u, u + a.length).set(a), T = a.length, u;
  }
  let r = n.length, i = e(r, 1) >>> 0;
  const s = te();
  let o = 0;
  for (; o < r; o++) {
    const a = n.charCodeAt(o);
    if (a > 127) break;
    s[i + o] = a;
  }
  if (o !== r) {
    o !== 0 && (n = n.slice(o)), i = t(i, r, r = o + n.length * 3, 1) >>> 0;
    const a = te().subarray(i + o, i + r), u = Pn(n, a);
    o += u.written, i = t(i, r, o, 1) >>> 0;
  }
  return T = o, i;
}
let X = null;
function S() {
  return (X === null || X.buffer.detached === !0 || X.buffer.detached === void 0 && X.buffer !== g.memory.buffer) && (X = new DataView(g.memory.buffer)), X;
}
function z(n) {
  return n == null;
}
const mt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => {
  g.__wbindgen_export_4.get(n.dtor)(n.a, n.b);
});
function In(n, e, t, r) {
  const i = { a: n, b: e, cnt: 1, dtor: t }, s = (...o) => {
    i.cnt++;
    const a = i.a;
    i.a = 0;
    try {
      return r(a, i.b, ...o);
    } finally {
      --i.cnt === 0 ? (g.__wbindgen_export_4.get(i.dtor)(a, i.b), mt.unregister(i)) : i.a = a;
    }
  };
  return s.original = i, mt.register(s, i, i), s;
}
function He(n) {
  const e = typeof n;
  if (e == "number" || e == "boolean" || n == null)
    return `${n}`;
  if (e == "string")
    return `"${n}"`;
  if (e == "symbol") {
    const i = n.description;
    return i == null ? "Symbol" : `Symbol(${i})`;
  }
  if (e == "function") {
    const i = n.name;
    return typeof i == "string" && i.length > 0 ? `Function(${i})` : "Function";
  }
  if (Array.isArray(n)) {
    const i = n.length;
    let s = "[";
    i > 0 && (s += He(n[0]));
    for (let o = 1; o < i; o++)
      s += ", " + He(n[o]);
    return s += "]", s;
  }
  const t = /\[object ([^\]]+)\]/.exec(toString.call(n));
  let r;
  if (t && t.length > 1)
    r = t[1];
  else
    return toString.call(n);
  if (r == "Object")
    try {
      return "Object(" + JSON.stringify(n) + ")";
    } catch {
      return "Object";
    }
  return n instanceof Error ? `${n.name}: ${n.message}
${n.stack}` : r;
}
function Mn(n, e) {
  return n = n >>> 0, te().subarray(n / 1, n / 1 + e);
}
function Gt(n, e) {
  const t = e(n.length * 1, 1) >>> 0;
  return te().set(n, t / 1), T = n.length, t;
}
function Ln(n) {
  const e = g.get_font_info(v(n));
  return I(e);
}
function An(n, e) {
  n = n >>> 0;
  const t = S(), r = [];
  for (let i = n; i < n + 4 * e; i += 4)
    r.push(I(t.getUint32(i, !0)));
  return r;
}
function de(n, e) {
  const t = e(n.length * 4, 4) >>> 0, r = S();
  for (let i = 0; i < n.length; i++)
    r.setUint32(t + 4 * i, v(n[i]), !0);
  return T = n.length, t;
}
function Tn(n, e) {
  if (!(n instanceof e))
    throw new Error(`expected instance of ${e.name}`);
}
function On(n, e, t) {
  g.__wbindgen_export_5(n, e, v(t));
}
function Fn(n, e, t, r) {
  g.__wbindgen_export_6(n, e, v(t), v(r));
}
const yt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => g.__wbg_incrserver_free(n >>> 0, 1));
class _e {
  static __wrap(e) {
    e = e >>> 0;
    const t = Object.create(_e.prototype);
    return t.__wbg_ptr = e, yt.register(t, t.__wbg_ptr, t), t;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, yt.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    g.__wbg_incrserver_free(e, 0);
  }
  /**
   * @param {boolean} attach
   */
  set_attach_debug_info(e) {
    g.incrserver_set_attach_debug_info(this.__wbg_ptr, e);
  }
  /**
   * @returns {Uint8Array | undefined}
   */
  current() {
    try {
      const r = g.__wbindgen_add_to_stack_pointer(-16);
      g.incrserver_current(r, this.__wbg_ptr);
      var e = S().getInt32(r + 4 * 0, !0), t = S().getInt32(r + 4 * 1, !0);
      let i;
      return e !== 0 && (i = Mn(e, t).slice(), g.__wbindgen_export_1(e, t * 1, 1)), i;
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  reset() {
    g.incrserver_reset(this.__wbg_ptr);
  }
}
const De = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => g.__wbg_proxycontext_free(n >>> 0, 1));
class xe {
  static __wrap(e) {
    e = e >>> 0;
    const t = Object.create(xe.prototype);
    return t.__wbg_ptr = e, De.register(t, t.__wbg_ptr, t), t;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, De.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    g.__wbg_proxycontext_free(e, 0);
  }
  /**
   * @param {any} context
   */
  constructor(e) {
    const t = g.proxycontext_new(v(e));
    return this.__wbg_ptr = t >>> 0, De.register(this, this.__wbg_ptr, this), this;
  }
  /**
   * @returns {any}
   */
  get context() {
    const e = g.proxycontext_context(this.__wbg_ptr);
    return I(e);
  }
  /**
   * @param {Uint8Array} data
   * @param {Function} cb
   */
  untar(e, t) {
    try {
      const s = g.__wbindgen_add_to_stack_pointer(-16), o = Gt(e, g.__wbindgen_export_2), a = T;
      g.proxycontext_untar(s, this.__wbg_ptr, o, a, v(t));
      var r = S().getInt32(s + 4 * 0, !0), i = S().getInt32(s + 4 * 1, !0);
      if (i)
        throw I(r);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
}
const vt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => g.__wbg_typstcompiler_free(n >>> 0, 1));
class ke {
  static __wrap(e) {
    e = e >>> 0;
    const t = Object.create(ke.prototype);
    return t.__wbg_ptr = e, vt.register(t, t.__wbg_ptr, t), t;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, vt.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    g.__wbg_typstcompiler_free(e, 0);
  }
  reset() {
    try {
      const r = g.__wbindgen_add_to_stack_pointer(-16);
      g.typstcompiler_reset(r, this.__wbg_ptr);
      var e = S().getInt32(r + 4 * 0, !0), t = S().getInt32(r + 4 * 1, !0);
      if (t)
        throw I(e);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {any} inputs
   */
  set_inputs(e) {
    try {
      const i = g.__wbindgen_add_to_stack_pointer(-16);
      g.typstcompiler_set_inputs(i, this.__wbg_ptr, v(e));
      var t = S().getInt32(i + 4 * 0, !0), r = S().getInt32(i + 4 * 1, !0);
      if (r)
        throw I(t);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} path
   * @param {string} content
   * @returns {boolean}
   */
  add_source(e, t) {
    const r = B(e, g.__wbindgen_export_2, g.__wbindgen_export_3), i = T, s = B(t, g.__wbindgen_export_2, g.__wbindgen_export_3), o = T;
    return g.typstcompiler_add_source(this.__wbg_ptr, r, i, s, o) !== 0;
  }
  /**
   * @param {string} path
   * @param {Uint8Array} content
   * @returns {boolean}
   */
  map_shadow(e, t) {
    const r = B(e, g.__wbindgen_export_2, g.__wbindgen_export_3), i = T, s = Gt(t, g.__wbindgen_export_2), o = T;
    return g.typstcompiler_map_shadow(this.__wbg_ptr, r, i, s, o) !== 0;
  }
  /**
   * @param {string} path
   * @returns {boolean}
   */
  unmap_shadow(e) {
    const t = B(e, g.__wbindgen_export_2, g.__wbindgen_export_3), r = T;
    return g.typstcompiler_unmap_shadow(this.__wbg_ptr, t, r) !== 0;
  }
  reset_shadow() {
    g.typstcompiler_reset_shadow(this.__wbg_ptr);
  }
  /**
   * @returns {string[]}
   */
  get_loaded_fonts() {
    try {
      const i = g.__wbindgen_add_to_stack_pointer(-16);
      g.typstcompiler_get_loaded_fonts(i, this.__wbg_ptr);
      var e = S().getInt32(i + 4 * 0, !0), t = S().getInt32(i + 4 * 1, !0), r = An(e, t).slice();
      return g.__wbindgen_export_1(e, t * 4, 4), r;
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} main_file_path
   * @returns {string}
   */
  get_ast(e) {
    let t, r;
    try {
      const f = g.__wbindgen_add_to_stack_pointer(-16), w = B(e, g.__wbindgen_export_2, g.__wbindgen_export_3), x = T;
      g.typstcompiler_get_ast(f, this.__wbg_ptr, w, x);
      var i = S().getInt32(f + 4 * 0, !0), s = S().getInt32(f + 4 * 1, !0), o = S().getInt32(f + 4 * 2, !0), a = S().getInt32(f + 4 * 3, !0), u = i, d = s;
      if (a)
        throw u = 0, d = 0, I(o);
      return t = u, r = d, V(u, d);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16), g.__wbindgen_export_1(t, r, 1);
    }
  }
  /**
   * @returns {any}
   */
  get_semantic_token_legend() {
    try {
      const i = g.__wbindgen_add_to_stack_pointer(-16);
      g.typstcompiler_get_semantic_token_legend(i, this.__wbg_ptr);
      var e = S().getInt32(i + 4 * 0, !0), t = S().getInt32(i + 4 * 1, !0), r = S().getInt32(i + 4 * 2, !0);
      if (r)
        throw I(t);
      return I(e);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} offset_encoding
   * @param {string | null} [file_path]
   * @param {string | null} [result_id]
   * @returns {object}
   */
  get_semantic_tokens(e, t, r) {
    try {
      const w = g.__wbindgen_add_to_stack_pointer(-16), x = B(e, g.__wbindgen_export_2, g.__wbindgen_export_3), C = T;
      var i = z(t) ? 0 : B(t, g.__wbindgen_export_2, g.__wbindgen_export_3), s = T, o = z(r) ? 0 : B(r, g.__wbindgen_export_2, g.__wbindgen_export_3), a = T;
      g.typstcompiler_get_semantic_tokens(w, this.__wbg_ptr, x, C, i, s, o, a);
      var u = S().getInt32(w + 4 * 0, !0), d = S().getInt32(w + 4 * 1, !0), f = S().getInt32(w + 4 * 2, !0);
      if (f)
        throw I(d);
      return I(u);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} fmt
   * @param {number} diagnostics_format
   * @returns {any}
   */
  get_artifact(e, t) {
    try {
      const o = g.__wbindgen_add_to_stack_pointer(-16), a = B(e, g.__wbindgen_export_2, g.__wbindgen_export_3), u = T;
      g.typstcompiler_get_artifact(o, this.__wbg_ptr, a, u, t);
      var r = S().getInt32(o + 4 * 0, !0), i = S().getInt32(o + 4 * 1, !0), s = S().getInt32(o + 4 * 2, !0);
      if (s)
        throw I(i);
      return I(r);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} main_file_path
   * @param {(Array<any>)[] | null} [inputs]
   */
  set_compiler_options(e, t) {
    try {
      const a = g.__wbindgen_add_to_stack_pointer(-16), u = B(e, g.__wbindgen_export_2, g.__wbindgen_export_3), d = T;
      var r = z(t) ? 0 : de(t, g.__wbindgen_export_2), i = T;
      g.typstcompiler_set_compiler_options(a, this.__wbg_ptr, u, d, r, i);
      var s = S().getInt32(a + 4 * 0, !0), o = S().getInt32(a + 4 * 1, !0);
      if (o)
        throw I(s);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} main_file_path
   * @param {(Array<any>)[] | null | undefined} inputs
   * @param {string} selector
   * @param {string | null} [field]
   * @returns {string}
   */
  query(e, t, r, i) {
    let s, o;
    try {
      const D = g.__wbindgen_add_to_stack_pointer(-16), tr = B(e, g.__wbindgen_export_2, g.__wbindgen_export_3), rr = T;
      var a = z(t) ? 0 : de(t, g.__wbindgen_export_2), u = T;
      const nr = B(r, g.__wbindgen_export_2, g.__wbindgen_export_3), ir = T;
      var d = z(i) ? 0 : B(i, g.__wbindgen_export_2, g.__wbindgen_export_3), f = T;
      g.typstcompiler_query(D, this.__wbg_ptr, tr, rr, a, u, nr, ir, d, f);
      var w = S().getInt32(D + 4 * 0, !0), x = S().getInt32(D + 4 * 1, !0), C = S().getInt32(D + 4 * 2, !0), F = S().getInt32(D + 4 * 3, !0), A = w, $ = x;
      if (F)
        throw A = 0, $ = 0, I(C);
      return s = A, o = $, V(A, $);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16), g.__wbindgen_export_1(s, o, 1);
    }
  }
  /**
   * @param {string} main_file_path
   * @param {(Array<any>)[] | null | undefined} inputs
   * @param {string} fmt
   * @param {number} diagnostics_format
   * @returns {any}
   */
  compile(e, t, r, i) {
    try {
      const f = g.__wbindgen_add_to_stack_pointer(-16), w = B(e, g.__wbindgen_export_2, g.__wbindgen_export_3), x = T;
      var s = z(t) ? 0 : de(t, g.__wbindgen_export_2), o = T;
      const C = B(r, g.__wbindgen_export_2, g.__wbindgen_export_3), F = T;
      g.typstcompiler_compile(f, this.__wbg_ptr, w, x, s, o, C, F, i);
      var a = S().getInt32(f + 4 * 0, !0), u = S().getInt32(f + 4 * 1, !0), d = S().getInt32(f + 4 * 2, !0);
      if (d)
        throw I(u);
      return I(a);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {IncrServer}
   */
  create_incr_server() {
    try {
      const i = g.__wbindgen_add_to_stack_pointer(-16);
      g.typstcompiler_create_incr_server(i, this.__wbg_ptr);
      var e = S().getInt32(i + 4 * 0, !0), t = S().getInt32(i + 4 * 1, !0), r = S().getInt32(i + 4 * 2, !0);
      if (r)
        throw I(t);
      return _e.__wrap(e);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} main_file_path
   * @param {(Array<any>)[] | null | undefined} inputs
   * @param {IncrServer} state
   * @param {number} diagnostics_format
   * @returns {any}
   */
  incr_compile(e, t, r, i) {
    try {
      const f = g.__wbindgen_add_to_stack_pointer(-16), w = B(e, g.__wbindgen_export_2, g.__wbindgen_export_3), x = T;
      var s = z(t) ? 0 : de(t, g.__wbindgen_export_2), o = T;
      Tn(r, _e), g.typstcompiler_incr_compile(f, this.__wbg_ptr, w, x, s, o, r.__wbg_ptr, i);
      var a = S().getInt32(f + 4 * 0, !0), u = S().getInt32(f + 4 * 1, !0), d = S().getInt32(f + 4 * 2, !0);
      if (d)
        throw I(u);
      return I(a);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
}
const St = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => g.__wbg_typstcompilerbuilder_free(n >>> 0, 1));
class Dn {
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, St.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    g.__wbg_typstcompilerbuilder_free(e, 0);
  }
  constructor() {
    try {
      const i = g.__wbindgen_add_to_stack_pointer(-16);
      g.typstcompilerbuilder_new(i);
      var e = S().getInt32(i + 4 * 0, !0), t = S().getInt32(i + 4 * 1, !0), r = S().getInt32(i + 4 * 2, !0);
      if (r)
        throw I(t);
      return this.__wbg_ptr = e >>> 0, St.register(this, this.__wbg_ptr, this), this;
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  set_dummy_access_model() {
    try {
      const r = g.__wbindgen_add_to_stack_pointer(-16);
      g.typstcompilerbuilder_set_dummy_access_model(r, this.__wbg_ptr);
      var e = S().getInt32(r + 4 * 0, !0), t = S().getInt32(r + 4 * 1, !0);
      if (t)
        throw I(e);
    } finally {
      g.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {any} context
   * @param {Function} mtime_fn
   * @param {Function} is_file_fn
   * @param {Function} real_path_fn
   * @param {Function} read_all_fn
   * @returns {Promise<void>}
   */
  set_access_model(e, t, r, i, s) {
    const o = g.typstcompilerbuilder_set_access_model(this.__wbg_ptr, v(e), v(t), v(r), v(i), v(s));
    return I(o);
  }
  /**
   * @param {any} context
   * @param {Function} real_resolve_fn
   * @returns {Promise<void>}
   */
  set_package_registry(e, t) {
    const r = g.typstcompilerbuilder_set_package_registry(this.__wbg_ptr, v(e), v(t));
    return I(r);
  }
  /**
   * @param {Uint8Array} font_buffer
   * @returns {Promise<void>}
   */
  add_raw_font(e) {
    const t = g.typstcompilerbuilder_add_raw_font(this.__wbg_ptr, v(e));
    return I(t);
  }
  /**
   * @param {Array<any>} fonts
   * @returns {Promise<void>}
   */
  add_web_fonts(e) {
    const t = g.typstcompilerbuilder_add_web_fonts(this.__wbg_ptr, v(e));
    return I(t);
  }
  /**
   * @param {any} _pack
   * @returns {Promise<void>}
   */
  add_glyph_pack(e) {
    const t = g.typstcompilerbuilder_add_glyph_pack(this.__wbg_ptr, v(e));
    return I(t);
  }
  /**
   * @returns {Promise<TypstCompiler>}
   */
  build() {
    const e = this.__destroy_into_raw(), t = g.typstcompilerbuilder_build(e);
    return I(t);
  }
}
async function $n(n, e) {
  if (typeof Response == "function" && n instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(n, e);
      } catch (r) {
        if (n.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", r);
        else
          throw r;
      }
    const t = await n.arrayBuffer();
    return await WebAssembly.instantiate(t, e);
  } else {
    const t = await WebAssembly.instantiate(n, e);
    return t instanceof WebAssembly.Instance ? { instance: t, module: n } : t;
  }
}
function Qt() {
  const n = {};
  return n.wbg = {}, n.wbg.__wbg_buffer_609cc3eee51ed158 = function(e) {
    const t = b(e).buffer;
    return v(t);
  }, n.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return Y(function(e, t) {
      const r = b(e).call(b(t));
      return v(r);
    }, arguments);
  }, n.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return Y(function(e, t, r) {
      const i = b(e).call(b(t), b(r));
      return v(i);
    }, arguments);
  }, n.wbg.__wbg_call_b8adc8b1d0a0d8eb = function() {
    return Y(function(e, t, r, i, s) {
      const o = b(e).call(b(t), b(r), b(i), b(s));
      return v(o);
    }, arguments);
  }, n.wbg.__wbg_done_769e5ede4b31c67b = function(e) {
    return b(e).done;
  }, n.wbg.__wbg_entries_3265d4158b33e5dc = function(e) {
    const t = Object.entries(b(e));
    return v(t);
  }, n.wbg.__wbg_error_13f62fdb4fc06f92 = function(e, t, r) {
    console.error(b(e), b(t), b(r));
  }, n.wbg.__wbg_error_7534b8e9a36f1ab4 = function(e, t) {
    let r, i;
    try {
      r = e, i = t, console.error(V(e, t));
    } finally {
      g.__wbindgen_export_1(r, i, 1);
    }
  }, n.wbg.__wbg_getTime_46267b1c24877e30 = function(e) {
    return b(e).getTime();
  }, n.wbg.__wbg_getTimezoneOffset_6b5752021c499c47 = function(e) {
    return b(e).getTimezoneOffset();
  }, n.wbg.__wbg_get_67b2ba62fc30de12 = function() {
    return Y(function(e, t) {
      const r = Reflect.get(b(e), b(t));
      return v(r);
    }, arguments);
  }, n.wbg.__wbg_get_b9b93047fe3cf45b = function(e, t) {
    const r = b(e)[t >>> 0];
    return v(r);
  }, n.wbg.__wbg_getwithrefkey_1dc361bd10053bfe = function(e, t) {
    const r = b(e)[b(t)];
    return v(r);
  }, n.wbg.__wbg_info_3daf2e093e091b66 = function(e) {
    console.info(b(e));
  }, n.wbg.__wbg_instanceof_ArrayBuffer_e14585432e3737fc = function(e) {
    let t;
    try {
      t = b(e) instanceof ArrayBuffer;
    } catch {
      t = !1;
    }
    return t;
  }, n.wbg.__wbg_instanceof_Map_f3469ce2244d2430 = function(e) {
    let t;
    try {
      t = b(e) instanceof Map;
    } catch {
      t = !1;
    }
    return t;
  }, n.wbg.__wbg_instanceof_Object_7f2dcef8f78644a4 = function(e) {
    let t;
    try {
      t = b(e) instanceof Object;
    } catch {
      t = !1;
    }
    return t;
  }, n.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9 = function(e) {
    let t;
    try {
      t = b(e) instanceof Uint8Array;
    } catch {
      t = !1;
    }
    return t;
  }, n.wbg.__wbg_isArray_a1eab7e0d067391b = function(e) {
    return Array.isArray(b(e));
  }, n.wbg.__wbg_isSafeInteger_343e2beeeece1bb0 = function(e) {
    return Number.isSafeInteger(b(e));
  }, n.wbg.__wbg_iterator_9a24c88df860dc65 = function() {
    return v(Symbol.iterator);
  }, n.wbg.__wbg_length_a446193dc22c12f8 = function(e) {
    return b(e).length;
  }, n.wbg.__wbg_length_e2d2a49132c1b256 = function(e) {
    return b(e).length;
  }, n.wbg.__wbg_log_53ca6abb454c8644 = function(e, t, r) {
    console.log(b(e), b(t), b(r));
  }, n.wbg.__wbg_new0_f788a2397c7ca929 = function() {
    return v(/* @__PURE__ */ new Date());
  }, n.wbg.__wbg_new_23a2665fac83c611 = function(e, t) {
    try {
      var r = { a: e, b: t }, i = (o, a) => {
        const u = r.a;
        r.a = 0;
        try {
          return Fn(u, r.b, o, a);
        } finally {
          r.a = u;
        }
      };
      const s = new Promise(i);
      return v(s);
    } finally {
      r.a = r.b = 0;
    }
  }, n.wbg.__wbg_new_31a97dac4f10fab7 = function(e) {
    const t = new Date(b(e));
    return v(t);
  }, n.wbg.__wbg_new_405e22f390576ce2 = function() {
    const e = new Object();
    return v(e);
  }, n.wbg.__wbg_new_78feb108b6472713 = function() {
    const e = new Array();
    return v(e);
  }, n.wbg.__wbg_new_8a6f238a6ece86ea = function() {
    const e = new Error();
    return v(e);
  }, n.wbg.__wbg_new_a12002a7f91c75be = function(e) {
    const t = new Uint8Array(b(e));
    return v(t);
  }, n.wbg.__wbg_new_c68d7209be747379 = function(e, t) {
    const r = new Error(V(e, t));
    return v(r);
  }, n.wbg.__wbg_new_e3b321dcfef89fc7 = function(e) {
    const t = new Uint32Array(b(e));
    return v(t);
  }, n.wbg.__wbg_newnoargs_105ed471475aaf50 = function(e, t) {
    const r = new Function(V(e, t));
    return v(r);
  }, n.wbg.__wbg_newwithargs_ab6ffe8cd6c19c04 = function(e, t, r, i) {
    const s = new Function(V(e, t), V(r, i));
    return v(s);
  }, n.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(e, t, r) {
    const i = new Uint8Array(b(e), t >>> 0, r >>> 0);
    return v(i);
  }, n.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(e, t, r) {
    const i = new Uint32Array(b(e), t >>> 0, r >>> 0);
    return v(i);
  }, n.wbg.__wbg_next_25feadfc0913fea9 = function(e) {
    const t = b(e).next;
    return v(t);
  }, n.wbg.__wbg_next_6574e1a8a62d1055 = function() {
    return Y(function(e) {
      const t = b(e).next();
      return v(t);
    }, arguments);
  }, n.wbg.__wbg_now_807e54c39636c349 = function() {
    return Date.now();
  }, n.wbg.__wbg_proxycontext_new = function(e) {
    const t = xe.__wrap(e);
    return v(t);
  }, n.wbg.__wbg_push_737cfc8c1432c2c6 = function(e, t) {
    return b(e).push(b(t));
  }, n.wbg.__wbg_queueMicrotask_97d92b4fcc8a61c5 = function(e) {
    queueMicrotask(b(e));
  }, n.wbg.__wbg_queueMicrotask_d3219def82552485 = function(e) {
    const t = b(e).queueMicrotask;
    return v(t);
  }, n.wbg.__wbg_resolve_4851785c9c5f573d = function(e) {
    const t = Promise.resolve(b(e));
    return v(t);
  }, n.wbg.__wbg_set_37837023f3d740e8 = function(e, t, r) {
    b(e)[t >>> 0] = I(r);
  }, n.wbg.__wbg_set_3f1d0b984ed272ed = function(e, t, r) {
    b(e)[I(t)] = I(r);
  }, n.wbg.__wbg_set_65595bdd868b3009 = function(e, t, r) {
    b(e).set(b(t), r >>> 0);
  }, n.wbg.__wbg_set_bb8cecf6a62b9f46 = function() {
    return Y(function(e, t, r) {
      return Reflect.set(b(e), b(t), b(r));
    }, arguments);
  }, n.wbg.__wbg_stack_0ed75d68575b0f3c = function(e, t) {
    const r = b(t).stack, i = B(r, g.__wbindgen_export_2, g.__wbindgen_export_3), s = T;
    S().setInt32(e + 4 * 1, s, !0), S().setInt32(e + 4 * 0, i, !0);
  }, n.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const e = typeof global > "u" ? null : global;
    return z(e) ? 0 : v(e);
  }, n.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const e = typeof globalThis > "u" ? null : globalThis;
    return z(e) ? 0 : v(e);
  }, n.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const e = typeof self > "u" ? null : self;
    return z(e) ? 0 : v(e);
  }, n.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const e = typeof window > "u" ? null : window;
    return z(e) ? 0 : v(e);
  }, n.wbg.__wbg_then_44b73946d2fb3e7d = function(e, t) {
    const r = b(e).then(b(t));
    return v(r);
  }, n.wbg.__wbg_typstcompiler_new = function(e) {
    const t = ke.__wrap(e);
    return v(t);
  }, n.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(e) {
    const t = b(e).value;
    return v(t);
  }, n.wbg.__wbindgen_as_number = function(e) {
    return +b(e);
  }, n.wbg.__wbindgen_bigint_from_i64 = function(e) {
    return v(e);
  }, n.wbg.__wbindgen_bigint_from_u64 = function(e) {
    const t = BigInt.asUintN(64, e);
    return v(t);
  }, n.wbg.__wbindgen_bigint_get_as_i64 = function(e, t) {
    const r = b(t), i = typeof r == "bigint" ? r : void 0;
    S().setBigInt64(e + 8 * 1, z(i) ? BigInt(0) : i, !0), S().setInt32(e + 4 * 0, !z(i), !0);
  }, n.wbg.__wbindgen_boolean_get = function(e) {
    const t = b(e);
    return typeof t == "boolean" ? t ? 1 : 0 : 2;
  }, n.wbg.__wbindgen_cb_drop = function(e) {
    const t = I(e).original;
    return t.cnt-- == 1 ? (t.a = 0, !0) : !1;
  }, n.wbg.__wbindgen_closure_wrapper16156 = function(e, t, r) {
    const i = In(e, t, 1129, On);
    return v(i);
  }, n.wbg.__wbindgen_debug_string = function(e, t) {
    const r = He(b(t)), i = B(r, g.__wbindgen_export_2, g.__wbindgen_export_3), s = T;
    S().setInt32(e + 4 * 1, s, !0), S().setInt32(e + 4 * 0, i, !0);
  }, n.wbg.__wbindgen_error_new = function(e, t) {
    const r = new Error(V(e, t));
    return v(r);
  }, n.wbg.__wbindgen_in = function(e, t) {
    return b(e) in b(t);
  }, n.wbg.__wbindgen_is_bigint = function(e) {
    return typeof b(e) == "bigint";
  }, n.wbg.__wbindgen_is_function = function(e) {
    return typeof b(e) == "function";
  }, n.wbg.__wbindgen_is_object = function(e) {
    const t = b(e);
    return typeof t == "object" && t !== null;
  }, n.wbg.__wbindgen_is_string = function(e) {
    return typeof b(e) == "string";
  }, n.wbg.__wbindgen_is_undefined = function(e) {
    return b(e) === void 0;
  }, n.wbg.__wbindgen_jsval_eq = function(e, t) {
    return b(e) === b(t);
  }, n.wbg.__wbindgen_jsval_loose_eq = function(e, t) {
    return b(e) == b(t);
  }, n.wbg.__wbindgen_memory = function() {
    const e = g.memory;
    return v(e);
  }, n.wbg.__wbindgen_number_get = function(e, t) {
    const r = b(t), i = typeof r == "number" ? r : void 0;
    S().setFloat64(e + 8 * 1, z(i) ? 0 : i, !0), S().setInt32(e + 4 * 0, !z(i), !0);
  }, n.wbg.__wbindgen_number_new = function(e) {
    return v(e);
  }, n.wbg.__wbindgen_object_clone_ref = function(e) {
    const t = b(e);
    return v(t);
  }, n.wbg.__wbindgen_object_drop_ref = function(e) {
    I(e);
  }, n.wbg.__wbindgen_string_get = function(e, t) {
    const r = b(t), i = typeof r == "string" ? r : void 0;
    var s = z(i) ? 0 : B(i, g.__wbindgen_export_2, g.__wbindgen_export_3), o = T;
    S().setInt32(e + 4 * 1, o, !0), S().setInt32(e + 4 * 0, s, !0);
  }, n.wbg.__wbindgen_string_new = function(e, t) {
    const r = V(e, t);
    return v(r);
  }, n.wbg.__wbindgen_throw = function(e, t) {
    throw new Error(V(e, t));
  }, n;
}
function Xt(n, e) {
  return g = n.exports, Yt.__wbindgen_wasm_module = e, X = null, ie = null, g;
}
function jn(n) {
  if (g !== void 0) return g;
  typeof n < "u" && (Object.getPrototypeOf(n) === Object.prototype ? { module: n } = n : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
  const e = Qt();
  n instanceof WebAssembly.Module || (n = new WebAssembly.Module(n));
  const t = new WebAssembly.Instance(n, e);
  return Xt(t, n);
}
async function Yt(n) {
  if (g !== void 0) return g;
  typeof n < "u" && (Object.getPrototypeOf(n) === Object.prototype ? { module_or_path: n } = n : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof n > "u" && (n = Zt("typst_ts_web_compiler_bg.wasm", import.meta.url));
  const e = Qt();
  (typeof n == "string" || typeof Request == "function" && n instanceof Request || typeof URL == "function" && n instanceof URL) && (n = fetch(n));
  const { instance: t, module: r } = await $n(await n, e);
  return Xt(t, r);
}
let Zt = async function(n, e) {
  throw new Error("Cannot import wasm module without importer: " + n + " " + e);
};
function er(n) {
  Zt = n;
}
let Bn = async function(n, e) {
  const t = new Function("m", "return import(m)"), r = await t("path"), { readFileSync: i } = await t("fs"), s = new URL(r.join(r.dirname(e), n));
  return await i(s).buffer;
};
const Wn = typeof process < "u" && process.versions != null && process.versions.node != null;
Wn && er(Bn);
const Re = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IncrServer: _e,
  ProxyContext: xe,
  TypstCompiler: ke,
  TypstCompilerBuilder: Dn,
  default: Yt,
  get_font_info: Ln,
  initSync: jn,
  setImportWasmModule: er
}, Symbol.toStringTag, { value: "Module" }));
export {
  ge as $typst,
  ur as FetchAccessModel,
  We as FetchPackageRegistry,
  U as TypstSnippet,
  Dr as createTypstCompiler,
  et as createTypstRenderer,
  Xn as createTypstSvgRenderer,
  $e as preloadRemoteFonts,
  Qe as preloadSystemFonts,
  Yn as rendererBuildInfo
};
